[
["returns.html", "Returns", " Returns Welcome to our section on asset returns, wherein we will perform the unglamorous work of taking raw price data for individual assets and tranforming them into monthly returns for a single portfolio. To map a data science work flow onto portfolio analysis, those steps encompass data import, cleaning, wrangling, transformation and initial visualization. Even though the subtstantive issues are not complex, we will painstakingly go through the code to ensure that the data provenance is clear, reproducible and reusable. In fact, we will devote as much time to this section as we do to any of the sections that are more analytical. That might seem a bit unbalanced - afterall, quants don’t get paid to import, clean and wrangle data. But it’s foundational to the more complex stuff and when done well, it makes the complex much less complex. Furthermore, our partners, collaborators and future selves will thank us for this effort when they want to update our models or extend our work or stress test with different assumptions. Here’s what we want to accomplish in this section: Import daily prices from the internet. Select the adjusted prices only. Transform daily prices to monthly prices. Transform monthly prices to monthly returns. Chart monthly returns. Choose allocations or weights for each asset. Calculate portfolio monthly returns based on asset monthly returns and weights. Chart portfolio returns Calculate growth of a dollar, given portfolio returns. Chart the growth of a dollar Save all of our data objects for use by our collaborators and future self We will use those saved objects throughouth the rest of this book, so this work is important! Our ultimate goal is to constructe a 5-asset portfolio consisting of the following. + SPY (S&amp;P500 fund) weighted 25% + EFA (a non-US equities fund) weighted 25% + IJS (a small-cap value fund) weighted 20% + EEM (an emerging-markets fund) weighted 20% + AGG (a bond fund) weighted 10% I chose those 5 assets because they seem to offer a balanced blend of large, small, international, emerging and bond exposure. We will include several Shiny applications in this book and those will enable you or any other end user to build a custom portfolio and see how things change. For the rest of our work inside of this book, we will not change or deviate from these 5 assets and the chosen portfolio. That said, changing to different assets and weights does not involve a heavy lift and I encourage you to experiment with different asset combinations. "],
["asset-prices-to-returns.html", "Chapter 2 Asset Prices to Returns", " Chapter 2 Asset Prices to Returns Importing Asset Prices Let’s get to step 1 wherein we import adjusted price data for the 5 ETFs to be used in our porftolio and save them to an xts object called prices. First, we need to choose ticker symbols and store them in a vector called symbols. We do that with symbols &lt;- c(&quot;SPY&quot;,&quot;EFA&quot;, &quot;IJS&quot;, &quot;EEM&quot;,&quot;AGG&quot;). Those are the tickers for the 5 assets in our portfolio. If you want to change to different assets for testing, change those tickers. We will then pass symbols to Yahoo! Finance via the getSymbols() function from the quantmod package. This will return an object with the opening price, closing price, adjusted price, daily high, daily low and daily volume. We don’t want to work with all of those, though. The adjusted price is what we want. Note that we are enforcing a starting date of “2013-01-01” and an end date of “2017-12-31”. That means we will be working with 5 years of data. If you wish to run this script or pull data that is up-to-date as of today, you can remove the argument to = &quot;2017-12-31&quot; - but then your raw data will be different from what is being used in this book. That’s fine, but the numbers will not match after that. To isolate the adjusted price, we use the map() function from the purrr package and apply Ad(get(.)) to the imported prices. This will get() the adjusted price from each of our individual price series. If we wanted the closing price, we would run Cl(get(.)). That . refers to our initial object. Note that if you wish to choose different stock tickers, you change the tickers in the symbols vector. We could stop here and have the right substance - daily prices for 5 tickers - but the format wouldn’t be great as we would have a list of 5 adjusted prices. Since those prices are xts objects, we would have a list of 5 xts objects. This is because the map() function returns a list by default. The reduce(merge) function will allow us to merge the 5 lists into one xts object. The merge() function looks for the date index shared by our objects and uses that index. Finally, we want intuitive column names and use colnames&lt;- to rename the columns according to the symbols object. The rename() function from dplyr will not work here because the object structure is still xts. Note that since we pull the names from the symbols object, we can change this portfolio by changing the tickers in symbols. symbols &lt;- c(&quot;SPY&quot;,&quot;EFA&quot;, &quot;IJS&quot;, &quot;EEM&quot;,&quot;AGG&quot;) prices &lt;- getSymbols(symbols, src = &#39;yahoo&#39;, from = &quot;2013-01-01&quot;, to = &quot;2017-12-31&quot;, auto.assign = TRUE, warnings = FALSE) %&gt;% map(~Ad(get(.))) %&gt;% reduce(merge) %&gt;% `colnames&lt;-`(symbols) Note that we are sourcing data from Yahoo! finance with src = 'yahoo' because that source is publicly available as of the time of this writing. In industry, we almost certainly wouldn’t be pulling from the internet but instead would be accesssing an internal database. In that situation, anyone wishing to reproduce or reuse or build upon our work must be able to import or update our raw data. It’s a simple but oft overlooked first step that needs to be made clear. Where did the raw data come from and what code path was used to access it? Make sure it can be run in a clean R environment, meaning one in which the Global Environment has been cleared. As to the starting date, I chose January 1, 2013 and the end date as December 31, 2017. Why? This book is being published in 2018 so we will be working with 5 years or 60 months of data and I like round numbers. Maybe my colleagues think that’s cherry picking because that’s 5 years of solid bull market behavior, maybe my clients think I need to go back to before the financial crisis bubble and do some stress testing. They are entitled to to their opinions, and I to mine. The important thing is to make it easy for someone to test his/her own permutations. If a colleague looks at our work and wants to test a start date that goes back to the internet bubble, we need to enable that. And, indeed, a date change can be accomplished in the code above by changing from = &quot;2013-01-01&quot; to from = &quot;some other date&quot;. Back to the code, we now have an xts object of the adjusted prices for our 5 assets. Have a quick peek. head(prices) ## SPY EFA IJS EEM AGG ## 2013-01-02 132.1244 49.92517 77.38805 40.67417 98.66173 ## 2013-01-03 131.8259 49.44096 77.28565 40.38634 98.41278 ## 2013-01-04 132.4049 49.69171 77.89076 40.46730 98.51948 ## 2013-01-07 132.0431 49.47555 77.43460 40.16148 98.46609 ## 2013-01-08 131.6631 49.19885 77.13670 39.80169 98.55505 ## 2013-01-09 131.9978 49.44961 77.36013 39.97258 98.48389 If you are running this code in the RStudio IDE, there will now be an object called prices in your Global Environment. Thoughts on Converting Daily Prices to Monthly Log Returns Next we want to turn those daily prices into monthly returns. This seems like a rather innocuous step in our work, but it involves two important decisions to be highlighted in the name of reproducibility. First, we are changing time periods from daily to monthly and thus we are transforming our data. We need to explain how that’s happening. Are we going to use the first day of each month? The last day? Does it matter? More importantly, we will be transforming our data from its raw form, adjusted prices, to a calculated form, log returns. This is such a standard step that the temptation is to include a few lines of code and move on to the analysis, which is the stuff our team gets paid to do. But, converting to log returns is our first major data processing decision: why did we choose log returns instead of simple returns? It’s a standard practice to use log returns but it’s also a good chance to set the precedent amongst our team and within our workflow that we justify and explain decisions about our data, even decisions that are standard operating procedure in the financial world. If we have made the decision to work with log returns across our work, we should point to an document or a paragraph that explains the decision and the brief substantive justification. In this case, I know that simulating returns is in our future in the Monte Carlo chapter, and we will be assuming a normal distribution of returns. Thus, I choose to convert to log returns. Plenty of people will disagree with making this transformation, then assuming a normal distribution, then simulating based on that assumption, and that’s fine. Converting Daily Prices to Monthly Returns in the xts World I mentioned in the introduction that we would be working in three universes - xts, tidyverse and tidyquant - the prices object is an xts, so we will start there.. The first observation in our prices object is January 2, 2013 (the first trading day of that year) and we have daily prices. We want to convert to those daily prices to monthly log returns based on the last reading of each month. We will use to.monthly(prices, indexAt = &quot;last&quot;, OHLC = FALSE) from the quantmod package. The argument index = &quot;last&quot; tells the function whether we want to index to the first day of the month or the last day. If we wanted to use the first day, we would change it to index = &quot;first&quot;. prices_monthly &lt;- to.monthly(prices, indexAt = &quot;last&quot;, OHLC = FALSE) head(prices_monthly) ## SPY EFA IJS EEM AGG ## 2013-01-31 135.4172 50.99734 79.35231 39.77470 98.16378 ## 2013-02-28 137.1450 50.34021 80.64629 38.86623 98.74377 ## 2013-03-28 142.3525 50.99734 83.95920 38.47046 98.84107 ## 2013-04-30 145.0875 53.55672 84.06191 38.93819 99.79841 ## 2013-05-31 148.5129 51.93981 87.66562 37.05829 97.80135 ## 2013-06-28 146.5311 50.54890 87.54271 35.08465 96.27032 We have moved from an xts object of daily prices to an xts object of monthly prices. Note that we now have one reading per month, for the last day of each month. Now we call Return.calculate(prices_monthly, method = &quot;log&quot;) to convert to returns and save as an object called assed_returns_xts. Note this will give us log returns by the method = &quot;log&quot; argument. We could have used method = &quot;discrete&quot; to get simple returns. asset_returns_xts &lt;- na.omit(Return.calculate(prices_monthly, method = &quot;log&quot;)) head(asset_returns_xts) ## SPY EFA IJS EEM AGG ## 2013-02-28 0.01267837 -0.01296933 0.016175294 -0.02310518 0.0058910455 ## 2013-03-28 0.03726809 0.01296933 0.040258091 -0.01023510 0.0009848732 ## 2013-04-30 0.01903021 0.04896781 0.001222644 0.01208477 0.0096390144 ## 2013-05-31 0.02333503 -0.03065564 0.041976206 -0.04948338 -0.0202138300 ## 2013-06-28 -0.01343411 -0.02714438 -0.001403016 -0.05472848 -0.0157783747 ## 2013-07-31 0.05038580 0.05186015 0.063541583 0.01315996 0.0026878683 Take a quick look at the monthly returns above, to make sure things appear to be in order. Notice in particular the date of the first value. We imported prices starting “2013-01-02” yet our first monthly return is for “2013-02-28”. This is because we used the argument indexAt = &quot;last&quot; when we cast to a monthly periodicity (try changing to indexAt = &quot;first&quot; and see the result). That is not necessarily good or bad, but it might matter if that first month’s returns makes a difference in our analysis. More broadly, it’s a good time to note how our decisions in data transformation can affect the data that ultimately survive to our analytical stage. We just lost the first two months of daily prices. From a subtantive perspective, we have accomplished our task: we have imported daily prices, trimmed to adjusted prices, moved to monthly prices and transformed to monthly log returns, all in the xts world. Let’s do the same thing but with a different coding paradigm in the tidy world. Converting Daily Prices to Monthly Returns in the Tidyverse We now take the same raw data, which is the prices object we created upon data import and convert it to monthly returns using 3 alternative methods. We will make use of the dplyr, tidyquant, timetk and tibbletime packages. There are lots of differences between the xts world and the tidy world but a very important one is the date. As noted above, xts objects have a date index. As we’ll see, data frames have a date column. We will see this difference in action soon but it’s good to keep in mind from the outset. Let’s get to it. Our conversion of the prices object from xts to a data frame will start with the very useful tk_tbl() function from the timetk package. In the piped workflow below, our first step is to use tk_tbl(preserve_index = TRUE, rename_index = &quot;date&quot;) function to convert from xts to tibble. The two arguments will convert the xts date index to a date column, and rename it “date”. If we stopped here, we would have a new object in tibble format. Next we turn to dplyr to gather() our new dataframe into long format and then group_by asset. We have not done any calculations yet, we have just shifted from wide format, to long, tidy format. Notice that when we gathered our data, we renamed one of the columns to returns even though the data are still prices. The next step will explain why we did that. Next, we want to calculate log returns and add those returns to the data frame. We will use mutate and our own calculation to get log returns: mutate(returns = (log(returns) - log(lag(returns)))). Notice that I am putting our new log returns into the returns column by calling returns = .... This is going to remove the price data and replace it with log returns data. This is the explanation for why, when we called gather in the previous step, we renamed the column to returns. That allows us to simply replace that column with log return data instead of having to create a new column and then delete the price data column. Our last two steps are to spread the data back to wide format, which makes it easier to compare to the xts object and easier to read, but is not a best practice in the tidyverse. We are going to look at this new object and compare to the xts object above, so we will stick with wide format for now. Finally, we want to reorder the columns so that the date column is first. asset_returns_dplyr_byhand &lt;- prices %&gt;% to.monthly(indexAt = &quot;last&quot;, OHLC = FALSE) %&gt;% tk_tbl(preserve_index = TRUE, rename_index = &quot;date&quot;) %&gt;% gather(asset, returns, -date) %&gt;% group_by(asset) %&gt;% mutate(returns = (log(returns) - log(lag(returns)))) %&gt;% spread(asset, returns) %&gt;% select(date, symbols) Have a quick peek at the new object. head(asset_returns_dplyr_byhand) ## # A tibble: 6 x 6 ## date SPY EFA IJS EEM AGG ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013-01-31 NA NA NA NA NA ## 2 2013-02-28 0.0127 - 0.0130 0.0162 - 0.0231 0.00589 ## 3 2013-03-28 0.0373 0.0130 0.0403 - 0.0102 0.000985 ## 4 2013-04-30 0.0190 0.0490 0.00122 0.0121 0.00964 ## 5 2013-05-31 0.0233 - 0.0307 0.0420 - 0.0495 - 0.0202 ## 6 2013-06-28 - 0.0134 - 0.0271 - 0.00140 - 0.0547 - 0.0158 Notice that our object now includes a reading for January 2013, whereas xts excluded it. Let’s make them consistent by removing that first row with the slice() function. asset_returns_dplyr_byhand &lt;- asset_returns_dplyr_byhand %&gt;% slice(-1) head(asset_returns_dplyr_byhand) ## # A tibble: 6 x 6 ## date SPY EFA IJS EEM AGG ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013-02-28 0.0127 -0.0130 0.0162 -0.0231 0.00589 ## 2 2013-03-28 0.0373 0.0130 0.0403 -0.0102 0.000985 ## 3 2013-04-30 0.0190 0.0490 0.00122 0.0121 0.00964 ## 4 2013-05-31 0.0233 -0.0307 0.0420 -0.0495 -0.0202 ## 5 2013-06-28 -0.0134 -0.0271 -0.00140 -0.0547 -0.0158 ## 6 2013-07-31 0.0504 0.0519 0.0635 0.0132 0.00269 Now our two objects are consistent and we have a data frame that we could use for further work. Converting Daily Prices to Monthly Returns in the tidyquant World Let’s explore a third pardigm where we’ll use the tq_transmute function from tidyquant. Instead of using to.monthly and mutate, and then supplying our own calculation, we use tq_transmute(mutate_fun = periodReturn, period = &quot;monthly&quot;, type = &quot;log&quot;) and go straight from daily prices to monthly log returns. Note that we select the period as ‘monthly’ in that function call, which means we can pass in the raw daily price xts object. asset_returns_tq_builtin &lt;- prices %&gt;% tk_tbl(preserve_index = TRUE, rename_index = &quot;date&quot;) %&gt;% gather(asset, prices, -date) %&gt;% group_by(asset) %&gt;% tq_transmute(mutate_fun = periodReturn, period = &quot;monthly&quot;, type = &quot;log&quot;) %&gt;% spread(asset, monthly.returns) %&gt;% select(date, symbols) %&gt;% slice(-1) head(asset_returns_tq_builtin) ## # A tibble: 6 x 6 ## date SPY EFA IJS EEM AGG ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013-02-28 0.0127 -0.0130 0.0162 -0.0231 0.00589 ## 2 2013-03-28 0.0373 0.0130 0.0403 -0.0102 0.000985 ## 3 2013-04-30 0.0190 0.0490 0.00122 0.0121 0.00964 ## 4 2013-05-31 0.0233 -0.0307 0.0420 -0.0495 -0.0202 ## 5 2013-06-28 -0.0134 -0.0271 -0.00140 -0.0547 -0.0158 ## 6 2013-07-31 0.0504 0.0519 0.0635 0.0132 0.00269 Note that we had to again remove the first row with slice(-1). Our second method in the tidyquant world will produce the same output as the previous two - a tibble of monthly log returns - but we will also introduce the tibbletime package Unlike the previous code chunk above where we went from daily prices straight to monthly returns, here we go from daily prices to monthly prices to monthly returns. That is, we will first create an xts of monthly prices, then a tibble, then a tibbletime object of monthly prices, then pipe to create monthly returns. We don’t have a substantive reason for doing that here, but it could prove useful if there’s a time when we need to get monthly prices in isolation during a tidyverse-based piped workflow. asset_returns_tbltime &lt;- prices %&gt;% to.monthly(indexAt = &quot;lastof&quot;, OHLC = FALSE) %&gt;% tk_tbl(preserve_index = TRUE, rename_index = &quot;date&quot;) %&gt;% tbl_time(index = &quot;date&quot;) %&gt;% gather(asset, returns, -date) %&gt;% group_by(asset) %&gt;% tq_transmute(mutate_fun = periodReturn, type = &quot;log&quot;) %&gt;% spread(asset, monthly.returns) %&gt;% select(date, symbols) %&gt;% slice(-1) Let’s take a peek at our 4 monthly log return objects. head(asset_returns_xts) ## SPY EFA IJS EEM AGG ## 2013-02-28 0.01267837 -0.01296933 0.016175294 -0.02310518 0.0058910455 ## 2013-03-28 0.03726809 0.01296933 0.040258091 -0.01023510 0.0009848732 ## 2013-04-30 0.01903021 0.04896781 0.001222644 0.01208477 0.0096390144 ## 2013-05-31 0.02333503 -0.03065564 0.041976206 -0.04948338 -0.0202138300 ## 2013-06-28 -0.01343411 -0.02714438 -0.001403016 -0.05472848 -0.0157783747 ## 2013-07-31 0.05038580 0.05186015 0.063541583 0.01315996 0.0026878683 head(asset_returns_dplyr_byhand) ## # A tibble: 6 x 6 ## date SPY EFA IJS EEM AGG ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013-02-28 0.0127 -0.0130 0.0162 -0.0231 0.00589 ## 2 2013-03-28 0.0373 0.0130 0.0403 -0.0102 0.000985 ## 3 2013-04-30 0.0190 0.0490 0.00122 0.0121 0.00964 ## 4 2013-05-31 0.0233 -0.0307 0.0420 -0.0495 -0.0202 ## 5 2013-06-28 -0.0134 -0.0271 -0.00140 -0.0547 -0.0158 ## 6 2013-07-31 0.0504 0.0519 0.0635 0.0132 0.00269 head(asset_returns_tq_builtin) ## # A tibble: 6 x 6 ## date SPY EFA IJS EEM AGG ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013-02-28 0.0127 -0.0130 0.0162 -0.0231 0.00589 ## 2 2013-03-28 0.0373 0.0130 0.0403 -0.0102 0.000985 ## 3 2013-04-30 0.0190 0.0490 0.00122 0.0121 0.00964 ## 4 2013-05-31 0.0233 -0.0307 0.0420 -0.0495 -0.0202 ## 5 2013-06-28 -0.0134 -0.0271 -0.00140 -0.0547 -0.0158 ## 6 2013-07-31 0.0504 0.0519 0.0635 0.0132 0.00269 head(asset_returns_tbltime) ## # A tibble: 6 x 6 ## date SPY EFA IJS EEM AGG ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013-02-28 0.0127 -0.0130 0.0162 -0.0231 0.00589 ## 2 2013-03-31 0.0373 0.0130 0.0403 -0.0102 0.000985 ## 3 2013-04-30 0.0190 0.0490 0.00122 0.0121 0.00964 ## 4 2013-05-31 0.0233 -0.0307 0.0420 -0.0495 -0.0202 ## 5 2013-06-30 -0.0134 -0.0271 -0.00140 -0.0547 -0.0158 ## 6 2013-07-31 0.0504 0.0519 0.0635 0.0132 0.00269 Do we notice anything of interest? First, have a look at the left most column/date in each object, where the date is stored. The asset_returns_xts has a date index, not a column. That index doesn’t have a name. It is accessed via index(asset_returns_xts). The data frame objects have a column called “date”, accessed via the $date convention, e.g. asset_returns_dplyr_byhand$date. Second, each of these objects is in “wide” format, which in this case means there is a column for each of our assets: SPY has a column, EFA has a column, IJS has a column, EEM has a colum, AGG has a column. This is the format that xts likes and it’s the format that is easier to read as a human. However, the tidyverse wants this data to be in long or tidy format so that each variable has its own column. For our asset_returns objects, that would mean a column called “date”, a column called “asset” and a column called “returns”. To see that in action, here is how it looks. asset_returns_long &lt;- asset_returns_dplyr_byhand %&gt;% gather(asset, returns, -date) head(asset_returns_long) ## # A tibble: 6 x 3 ## date asset returns ## &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2013-02-28 SPY 0.0127 ## 2 2013-03-28 SPY 0.0373 ## 3 2013-04-30 SPY 0.0190 ## 4 2013-05-31 SPY 0.0233 ## 5 2013-06-28 SPY -0.0134 ## 6 2013-07-31 SPY 0.0504 asset_returns_long has 3 columns, one for each variable: date, asset, return As I said, this format is harder to read as a human - we can see only the first several reading for one asset. From a tidyverse perspective, this is considered ‘tidy’ data or long data and it’s the preferred format. When we get to visualizing and manipulating this data, it will be clearer as to why the tidyverse likes this format. For now, spend a few minutes looking at the xts object asset_returns_xts and our various data frames, then look at the long, tidy object asset_returns_long object. Make sure that logic of how we got from daily prices to log returns for each object makes sense. A Word on workflow and recap Let’s recap what we’ve done thus far. We have imported raw price data for 5 assets, in a reprudicible and flexible way. We have used 4 different methods for converting those daily prices to monthly, log returns. From those 4 methods, we now have 5 objects: asset_returns_xts (an xts object), asset_returns_dplyr_byhand, asset_returns_tq_builtin, asset_returns_tbltime and asset_returns_long (a data frame in long instead of wide format). We can think of our work thus far in terms of a wholistic data science workflow, that begins with data import and transformation. Data import and transformation is not the most exciting of work but it needs to be so crystal clear that our colleagues find it stunningly easy to follow the origin of our data. If we wish for our work to lay the ground work for several potential projects or test strategies that will increase in complexity, this first step needs to be clear and accessible. There’s a high likelihood that we will encounter work from other team members who have their own methods for data import and transformation. The more methods we can master or at least practice, the better prepared we will be to reuse or expand on our colleagues’ work. Data import and transofrmation is straightforward, but it also forces us to engage with our data in its rawest form, instead of skipping ahead to the model and the R squared. A data scientist can never spend too much time getting to know his/her data. Perhaps new insights will jump out, or an error will be found, or a new hypothesis. Furthermore, when it comes time to defend or update our findings or conclusions, deep knowledge of the raw data is crucial. Visualizing Asset Returns before they get mashed into a portfolio We could jump straight into the process of converting these assets into a portfolio, but it’s good practice to look at the individual charts before doing so. Once a portfolio is built, we’re unlikely to back track to visualizing returns on an individual basis. Yet, those individual returns are the building blocks and raw material of our portfolio. Visualizing their returns adds another chance to get to know our raw data. For the purposes of visualizing returns, we will work with two of our monthly log returns objects, asset_returns_xts and asset_returns_long (the tidy, long formatted data frame) First, we ill use the highcharter package to visualize the xts formatted returns. highcharter is an R package but Highcharts is a javascript library - the R package is a hook into the javascript library. Highcharts is fantast for visualizing time series and it comes with great built-in widgets for viewing different time frames. I highly recommend it for visualizing financial time series but you do need to buy a license to use it in a commercial setting. Not only are the visualizations nice, but it “just works” with xts objects in the sense that it reads the index as dates withouth needing to be told. We pass in an xts object and let the package do the rest. With that, let’s get to it. First, we set highchart(type = &quot;stock&quot;) to get a nice line format which was purpose built for stocks. Then we add each of our series to the highcharter code flow with hc_add_series(asset_returns_xts[, symbols[1]], name = symbols[1]). Notice that we can use our original symbols object to reference the columns. This will allow the code to run should we change to different ticker symbols at the outset. highchart(type = &quot;stock&quot;) %&gt;% hc_title(text = &quot;Monthly Log Returns&quot;) %&gt;% hc_add_series(asset_returns_xts[, symbols[1]], name = symbols[1]) %&gt;% hc_add_series(asset_returns_xts[, symbols[2]], name = symbols[2]) %&gt;% hc_add_series(asset_returns_xts[, symbols[3]], name = symbols[3]) %&gt;% hc_add_series(asset_returns_xts[, symbols[4]], name = symbols[4]) %&gt;% hc_add_series(asset_returns_xts[, symbols[5]], name = symbols[5]) %&gt;% hc_add_theme(hc_theme_flat()) %&gt;% hc_navigator(enabled = FALSE) %&gt;% hc_scrollbar(enabled = FALSE) Take a look at the chart. It has a line for the monthly log returns of each our ETFs (and in my opinion it’s starting to get crowded). Do any months jump out at us? EEM looks to have suffered at the beginning of 2014 Highcharter also has the capacity for histogram making. One method is to first call the base function hist on the data along with the arguments for breaks and plot = FALSE. Then we can call hchart on that object. hc_hist &lt;- hist(asset_returns_xts[, symbols[1]], breaks = 50, plot = FALSE) hchart(hc_hist) %&gt;% hc_title(text = paste(symbols[1], &quot;Log Returns Distribution&quot;, sep = &quot; &quot;)) That’s a nice histogram but highcharter doesn’t have a smooth way to create 5 histograms as we need to do. Luckily, we can use ggplot() to operate on our tidy data frame assets_returns_long. We call ggplot(aes(x = returns, fill = asset)) + geom_histogram(alpha = 0.25, binwidth = .005) and because the data frame is grouped by the ‘asset’ column, ggplot() knows to chart a separate histogram for each asset. ggplot() will automatically include a legend since we included fill = asset in the aes() call. theme_update(plot.title = element_text(hjust = 0.5)) asset_returns_long %&gt;% ggplot(aes(x = returns, fill = asset)) + geom_histogram(alpha = 0.25, binwidth = .005) That looks nice, but it would be convenient to separate by asset. Let’s use facet_wrap(~asset) to break into 5 separate chars and add a title with ggtitle. asset_returns_long %&gt;% ggplot(aes(x = returns, fill = asset)) + geom_histogram(alpha = 0.25, binwidth = .01) + facet_wrap(~asset) + ggtitle(&quot;Monthly Returns Since 2013&quot;) Maybe we prefer to use a density line to visualize the various distributions. We can use the stat_density(geom = &quot;line&quot;, alpha = 1) function to do this. The alpha argument is selecting a line thickness. Let’s also add a label to the x and y axis with the xlab and ylab functions. asset_returns_long %&gt;% ggplot(aes(x = returns, colour = asset, fill = asset)) + stat_density(geom = &quot;line&quot;, alpha = 1) + ggtitle(&quot;Monthly Returns Since 2005&quot;) + xlab(&quot;monthly returns&quot;) + ylab(&quot;distribution&quot;) That chart is quite digestible, but we can also facet_wrap(~asset) to break the densities out into individual charts. asset_returns_long %&gt;% ggplot(aes(x = returns, colour = asset, fill = asset)) + stat_density(geom = &quot;line&quot;, alpha = 1) + facet_wrap(~asset) + ggtitle(&quot;Monthly Returns Since 2005&quot;) + xlab(&quot;monthly returns&quot;) + ylab(&quot;distribution&quot;) Okay, we have made histograms and density plots. Perhaps we would like to combine both of those into one chart. ggplot() works in aesthetic layers, which means we can chart a historgram in one layer, and then add a layer with a density chart. asset_returns_long %&gt;% ggplot(aes(x = returns, colour = asset, fill = asset)) + stat_density(geom = &quot;line&quot;, alpha = 1) + geom_histogram(alpha = 0.25, binwidth = .01) + facet_wrap(~asset) + ggtitle(&quot;Monthly Returns Since 2005&quot;) + xlab(&quot;monthly returns&quot;) + ylab(&quot;distribution&quot;) We now have one chart, with histograms and line densities broken out for each of our assets. This would scale nicely if we had more assets and wanted to peek at more distributions of returns. "],
["to-the-portfolio-station.html", "Chapter 3 To the Portfolio Station", " Chapter 3 To the Portfolio Station We spent a lot of time on the invidual assets to make sure we had a good grasp of our data building blocks. Now, we turn our collection of individual returns into a portfolio, which is really a weighted collection of asset returns. Accordingly, the first thing we need to do is assign a weight to each asset. Recall that our vector of symbols is SPY, EFA, IJS, EEM, AGG. Let’s create a weights vector that will allow us to assign a weight to each of our symbols. We are going for a balanced portfolio and will weight relatively little to AGG, the bond fund. w &lt;- c(0.25, 0.25, 0.20, 0.20, 0.10) Before we use the weights in our calculations, a quick sanity check in the next code chunk is a good idea. This might not be necessary with 5 assets as we have today, but good practice because if we had 50 assets it could save us a lot of grief to catch a mistake early. asset_weights_sanity_check &lt;- tibble(w, symbols) asset_weights_sanity_check ## # A tibble: 5 x 2 ## w symbols ## &lt;dbl&gt; &lt;chr&gt; ## 1 0.250 SPY ## 2 0.250 EFA ## 3 0.200 IJS ## 4 0.200 EEM ## 5 0.100 AGG Does that tibble match up with the portfolio we want to create? Looks good to me. Finally, make sure the weights sum to 100%, or 1. Again, we can eyeball this with 5 assets, but with 50 assets it would be easier to run the sanity check. sum(asset_weights_sanity_check$w) ## [1] 1 All looks good. Now let’s code up some portfolio returns. The textbook equation for the return of a multi-asset portfolio is: \\[Return_{portfolio} = W_{1}*Return_{asset1}~+~W_{2}*Return_{asset2}~+~W_{3}*Return_{asset3}~+~W_{4}*Return_{asset4}~+~W_{5}*Return_{asset5}\\] where the W’s stand for the weights of each asset. Let’s implement that equation with R code. First, we assign weights to variables according to our weights vector w. w_1 &lt;- w[1] w_2 &lt;- w[2] w_3 &lt;- w[3] w_4 &lt;- w[4] w_5 &lt;- w[5] We can assign returns by pulling out columns form the asset_returns_xts object. asset1 &lt;- asset_returns_xts[,1] asset2 &lt;- asset_returns_xts[,2] asset3 &lt;- asset_returns_xts[,3] asset4 &lt;- asset_returns_xts[,4] asset5 &lt;- asset_returns_xts[,5] Now let’s use the weights and returns in the equation and glance at the first few rows. portfolio_returns_byhand &lt;- (w_1 * asset1) + (w_2 * asset2) + (w_3 * asset3) + (w_4 * asset4) + (w_5 * asset5) names(portfolio_returns_byhand) &lt;- &quot;returns&quot; head(portfolio_returns_byhand) ## returns ## 2013-02-28 -0.0008696144 ## 2013-03-28 0.0186624413 ## 2013-04-30 0.0206248875 ## 2013-05-31 -0.0053529706 ## 2013-06-28 -0.0229487591 ## 2013-07-31 0.0411705817 tail(portfolio_returns_byhand) ## returns ## 2017-07-31 0.0247820474 ## 2017-08-31 0.0006890297 ## 2017-09-29 0.0266248779 ## 2017-10-31 0.0177227857 ## 2017-11-30 0.0156993906 ## 2017-12-29 0.0134430648 Our by-hand method is complete. We now have portfolio returns starting on February 28, 2013 through December 29, 2017. Let’s confirm we get the same results with the built-in methods. Portfolio Returns in the xts world For our first built-in method, we will stay in the xts world and use the Return.portfolio() function from the PerformanceAnalytics package. The function requires two arguments for a portfolio, an xts object of returns and a vector of weights. It’s not necessary but we are also going to set rebalance_on = &quot;months&quot; so we can confirm it matches our by hand calculations above. Remember, in the by-hand equation, we set the portfolio weights as fixed, meaning they never changed on a month-to-month basis. That is equivalent to rebalancing every month. In practice, that would be quite rare. Once we confirm that it matches our by hand, we can toggle over to a more realistic annual rebalancing by changing the argument to rebalance_on = &quot;years&quot;. portfolio_returns_xts_rebalanced_monthly &lt;- Return.portfolio(asset_returns_xts, weights = w, rebalance_on = &quot;months&quot;) %&gt;% `colnames&lt;-`(&quot;returns&quot;) Let’s use the built-in Return.portfolio function again but we will set a more realistic annual rebalancing with the argument rebalance_on = &quot;years&quot;. This will change our results so that they no longer our by-hand calculation, which effectiely rebalanced every month. portfolio_returns_xts_rebalanced_yearly &lt;- Return.portfolio(asset_returns_xts, weights = w, rebalance_on = &quot;years&quot;) %&gt;% `colnames&lt;-`(&quot;returns&quot;) We can take a peek at our three portfolio objects and see how the annual rebalance made a small but important difference to our monthly returns. head(portfolio_returns_byhand) ## returns ## 2013-02-28 -0.0008696144 ## 2013-03-28 0.0186624413 ## 2013-04-30 0.0206248875 ## 2013-05-31 -0.0053529706 ## 2013-06-28 -0.0229487591 ## 2013-07-31 0.0411705817 head(portfolio_returns_xts_rebalanced_monthly) ## returns ## 2013-02-28 -0.0008696144 ## 2013-03-28 0.0186624413 ## 2013-04-30 0.0206248875 ## 2013-05-31 -0.0053529706 ## 2013-06-28 -0.0229487591 ## 2013-07-31 0.0411705817 head(portfolio_returns_xts_rebalanced_yearly) ## returns ## 2013-02-28 -0.0008696144 ## 2013-03-28 0.0189330938 ## 2013-04-30 0.0204344992 ## 2013-05-31 -0.0044738094 ## 2013-06-28 -0.0218914135 ## 2013-07-31 0.0425168040 Do you notice where the annual rebalancing made a difference? It’s an important decision for our portfolio. As before, we could stop here and have accomplished our substantive task (twice already - by-hand and using the built-in function), but we want to explore alternate methods in the world of tidyverse and tidyquant. Portfolio Returns in the tidyverse We have our tidy object of asset returns and we need to add a weights column to it using the mutate() function. Each asset should be weighted according to the w vector. We can nested if_else() statements for this to make sure our weights match our assets. portfolio_returns_dplyr_byhand &lt;- asset_returns_long %&gt;% group_by(asset) %&gt;% mutate(weights = if_else(asset == symbols[1], w[1], if_else(asset == symbols[2], w[2], if_else(asset == symbols[3], w[3], if_else(asset == symbols[4], w[4], w[5]))))) portfolio_returns_dplyr_byhand ## # A tibble: 295 x 4 ## # Groups: asset [5] ## date asset returns weights ## &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013-02-28 SPY 0.0127 0.250 ## 2 2013-03-28 SPY 0.0373 0.250 ## 3 2013-04-30 SPY 0.0190 0.250 ## 4 2013-05-31 SPY 0.0233 0.250 ## 5 2013-06-28 SPY -0.0134 0.250 ## 6 2013-07-31 SPY 0.0504 0.250 ## 7 2013-08-30 SPY -0.0305 0.250 ## 8 2013-09-30 SPY 0.0312 0.250 ## 9 2013-10-31 SPY 0.0453 0.250 ## 10 2013-11-29 SPY 0.0292 0.250 ## # ... with 285 more rows We have weights and returns lined up, now we need to implement the equation above. This one is a bit tricky but we’ll need to group_by() the date column before using arithmetic. That’s because each of our weighted returns needs to be added together for each date. Once we group by date, we can use summarise(total = sum(weighted_returns)) to add up the monthly weighted returns. portfolio_returns_dplyr_byhand &lt;- asset_returns_long %&gt;% group_by(asset) %&gt;% mutate(weights = if_else(asset == symbols[1], w[1], if_else(asset == symbols[2], w[2], if_else(asset == symbols[3], w[3], if_else(asset == symbols[4], w[4], w[5])))), weighted_returns = returns * weights) %&gt;% group_by(date) %&gt;% summarise(port_returns = sum(weighted_returns)) portfolio_returns_dplyr_byhand ## # A tibble: 59 x 2 ## date port_returns ## &lt;date&gt; &lt;dbl&gt; ## 1 2013-02-28 -0.000870 ## 2 2013-03-28 0.0187 ## 3 2013-04-30 0.0206 ## 4 2013-05-31 -0.00535 ## 5 2013-06-28 -0.0229 ## 6 2013-07-31 0.0412 ## 7 2013-08-30 -0.0255 ## 8 2013-09-30 0.0544 ## 9 2013-10-31 0.0352 ## 10 2013-11-29 0.0162 ## # ... with 49 more rows That piped workflow required some logical hoops - it isn’t very smooth frankly but useful to see how to add those weights and then group by the date for finding total returns. Think about how we would solve the puzzle of rebalancing weights not every month, but every year? Portfolio Returns in the tidyquant World First, we will use our long, tidy formatted asset_returns_long and convert to portfolio returns using the tq_portfolio function from tidyquant. The tq_portfolio function takes a tibble and then asks for an assets column to group by, a returns column to find return data, and a weights vector It’s a wrapper for Return.portfolio() and thus also accepts the argument rebalance_on = &quot;months&quot;. Since we are rebalancing by months, we should again get a portfolio returns object that matches our two existing objects portfolio_returns_byhand and portfolio_returns_xts_rebalanced_monthly. portfolio_returns_tq_rebalanced_monthly &lt;- asset_returns_long %&gt;% tq_portfolio(assets_col = asset, returns_col = returns, weights = w, col_rename = &quot;returns&quot;, rebalance_on = &quot;months&quot;) If we want to rebalance annually, it’st the same code as above, except we set rebalance_on = &quot;years&quot;. portfolio_returns_tq_rebalanced_yearly &lt;- asset_returns_long %&gt;% tq_portfolio(assets_col = asset, returns_col = returns, weights = w, col_rename = &quot;returns&quot;, rebalance_on = &quot;years&quot;) We now have two more portfolio returns objects and they are both tidy tibbles. Let’s take a quick look and compare how a tidy tibbles of portfolio returns compare to the xts object of portfolio returns. head(portfolio_returns_byhand) ## returns ## 2013-02-28 -0.0008696144 ## 2013-03-28 0.0186624413 ## 2013-04-30 0.0206248875 ## 2013-05-31 -0.0053529706 ## 2013-06-28 -0.0229487591 ## 2013-07-31 0.0411705817 head(portfolio_returns_dplyr_byhand) ## # A tibble: 6 x 2 ## date port_returns ## &lt;date&gt; &lt;dbl&gt; ## 1 2013-02-28 -0.000870 ## 2 2013-03-28 0.0187 ## 3 2013-04-30 0.0206 ## 4 2013-05-31 -0.00535 ## 5 2013-06-28 -0.0229 ## 6 2013-07-31 0.0412 head(portfolio_returns_tq_rebalanced_monthly) ## # A tibble: 6 x 2 ## date returns ## &lt;date&gt; &lt;dbl&gt; ## 1 2013-02-28 -0.000870 ## 2 2013-03-28 0.0187 ## 3 2013-04-30 0.0206 ## 4 2013-05-31 -0.00535 ## 5 2013-06-28 -0.0229 ## 6 2013-07-31 0.0412 head(portfolio_returns_xts_rebalanced_monthly) ## returns ## 2013-02-28 -0.0008696144 ## 2013-03-28 0.0186624413 ## 2013-04-30 0.0206248875 ## 2013-05-31 -0.0053529706 ## 2013-06-28 -0.0229487591 ## 2013-07-31 0.0411705817 Huzzah, we have four objects of portfolio returns, calculated in four different ways, and with the same results. As we move on to visualization, we will make use of those different objects for our different visualization techniques. Visualizing Portfolio Returns As before, let’s start wiht highcharter to visualize the xts formatted portfolio returns. As we noted when looking at individual asset returns, highcharter is fantastic for visualizing a time series or many time series. First, we set highchart(type = &quot;stock&quot;) to get a nice time series line. Then we add our returns column from the portfolio returns xts object. We don’t have to add the date index or point to it in any way because highcharter recognizes the xts object and ports over the date index under the hood. The code below should look familiar from our work on asset returns. highchart(type = &quot;stock&quot;) %&gt;% hc_title(text = &quot;Porftolio Monthly Returns&quot;) %&gt;% hc_add_series(portfolio_returns_xts_rebalanced_monthly$returns, name = &quot;Rebalanced Yearly&quot;, color = &quot;cornflowerblue&quot;) %&gt;% hc_add_theme(hc_theme_flat()) %&gt;% hc_navigator(enabled = FALSE) %&gt;% hc_scrollbar(enabled = FALSE) As before, we can use highcharter for histogram making, with the same code flow. hc_portfolio &lt;- hist(portfolio_returns_xts_rebalanced_monthly$returns, breaks = 50, plot = FALSE) hchart(hc_portfolio) %&gt;% hc_title(text = &quot;Portfolio Returns Distribution&quot;) As we noted in the previous section on asset returns, there’s nothing wrong with that highcharter histogram. It displays well the distribution of portfolio returns. It does not, however, offer as much flexibility as ggplot for adding other distributions or density lines to the same chart. For that, we will head to the tidyverse and use ggplot on our tidy tibble portfolio_returns_tq_rebalanced_monthly. portfolio_returns_tq_rebalanced_monthly %&gt;% ggplot(aes(x = returns)) + geom_histogram(binwidth = .005, fill = &quot;cornflowerblue&quot;, color = &quot;cornflowerblue&quot;) + ggtitle(&quot;Portfolio Returns Distribution&quot;) + theme_update(plot.title = element_text(hjust = 0.5)) ggplot() makes it seemless to layer on other distributions. Let’s compare the portfolio distribution to those of our individual assets. Use the alpha argument to make the asset histograms a bid faded, since there are more of them and the portfolio return is what we really want to see. asset_returns_long %&gt;% ggplot(aes(x = returns, fill = asset)) + geom_histogram(alpha = 0.15, binwidth = .01) + geom_histogram(data = portfolio_returns_tq_rebalanced_monthly, fill = &quot;cornflowerblue&quot;) + ggtitle(&quot;Portfolio and Asset Monthly Returns Since 2005&quot;) Let’s turn to a new chart format and build a scatterplot of portfolio returns. I would like to see the returns over time so will put the date on the x-axis with ggplot(aes(x = date)). We put monthly returns on the y-axis with geom_point(aes(y = returns), color = &quot;cornflowerblue&quot;). portfolio_returns_tq_rebalanced_monthly %&gt;% ggplot(aes(x = date)) + geom_point(aes(y = returns), color = &quot;cornflowerblue&quot;) Maybe we don’t want to use a histogram or scatterplot, but instead want to use a density line to visualize the portfolio returns distributions. We can use the stat_density(geom = &quot;line&quot;, alpha = 1) function to do this, as we did before. The alpha argument is selecting a line thickness. Let’s also add a label to the x and y axis with the xlab and ylab functions. portfolio_returns_tq_rebalanced_monthly %&gt;% ggplot(aes(x = returns)) + stat_density(geom = &quot;line&quot;, alpha = 1, colour = &quot;cornflowerblue&quot;) + ggtitle(&quot;Portfolio Monthly Returns Since 2005&quot;) + xlab(&quot;monthly returns&quot;) + ylab(&quot;distribution&quot;) Now let’s put the portfolio returns histogram and density on one plot. We do that by layering our geoms. First we call geom_histogram(binwidth = .005, colour = &quot;cornflowerblue&quot;, fill = &quot;cornflowerblue&quot;) then we add another layer with stat_density(geom = &quot;line&quot;, alpha = 1, color = &quot;pink&quot;). portfolio_returns_tq_rebalanced_monthly %&gt;% ggplot(aes(x = returns)) + geom_histogram(binwidth = .005, colour = &quot;cornflowerblue&quot;, fill = &quot;cornflowerblue&quot;) + stat_density(geom = &quot;line&quot;, alpha = 1, color = &quot;pink&quot;) + xlab(&quot;monthly returns&quot;) + ylab(&quot;distribution&quot;) + theme_update(plot.title = element_text(hjust = 0.5)) + ggtitle(&quot;Portfolio Monthly Returns Since 2005&quot;) We have done a lot of work to visualize this portfolio. Now let’s build a Shiny application and enable end users to make their own decisions. Our First Shiny App: Portfolio Returns A Shiny application is a flexible, useful and powerful way to share our work. In this section, we will build a Shiny app to display portfolio returns using the various visualization frameworks above. We want to empower an end user to do the following: choose tickers and portfolio weights choose a start date choose a rebalancing frequency calculate portfolio returns visualize the portfolio returns on a scatterplot, histogram and density chart The final app and full source code can be seen here: www.reproduciblefinance.com/shiny/returns-distribution/ And here is a snapshot FIGURE 3.1: Returns Distribution Shiny App The application encompasses much of our work thus far as it requires importing daily price data, converting to monthly log returns, assigning portfolio weights, calculating portfolio returns, and visualizing with ggplot. This makes our work more flexible since the user can construct any 5-asset portfolio for which there’s data in our data source. And, the number 5 is for illustrative purposes. Our app could easily support 50 assets (though consider the user experience there - will anyone manually enter 50 ticker symbols? They would probably want to upload a csv file - a different challenge for us). Let’s get to the code. We will use Rmarkdown to build our Shiny applications by inserting into the yaml runtime: shiny. This will alert the server (or our laptop) that this is an interactive document. The yaml also gives us a space for the title. --- title: &quot;Returns Shiny&quot; runtime: shiny output: flexdashboard::flex_dashboard: orientation: rows --- As with other R scripts, we’ll need to load the necessary packages. library(tidyverse) library(highcharter) library(tidyquant) library(timetk) With the logistics out of the way, our first task is to build an input sidebar and enable users to choose five stocks and weights. We will use textInput(&quot;stock1&quot;,...)) to create a space where the user can type a stock symbol and we will use numericInput(&quot;w1&quot;,...) to create a space where the user can enter a numeric weight. We want those entry spaces to be on the same line or row so we will nest them inside of a call to fluidRow() Since we have 5 stocks and weights, we repeat this 5 times. Notice that the stock symbol field uses textInput() because the user needs to enter text and the weight field uses numericInput() because the user needs to enter a number. I highly recommend taking a quick look at the app but there’s also a screenshot below. fluidRow( column(6, textInput(&quot;stock1&quot;, &quot;Stock 1&quot;, &quot;SPY&quot;)), column(5, numericInput(&quot;w1&quot;, &quot;Portf. %&quot;, 25, min = 1, max = 100)) ) fluidRow( column(6, textInput(&quot;stock2&quot;, &quot;Stock 2&quot;, &quot;EFA&quot;)), column(5, numericInput(&quot;w2&quot;, &quot;Portf. %&quot;, 25, min = 1, max = 100)) ) fluidRow( column(6, textInput(&quot;stock3&quot;, &quot;Stock 3&quot;, &quot;IJS&quot;)), column(5, numericInput(&quot;w3&quot;, &quot;Portf. %&quot;, 20, min = 1, max = 100)) ) fluidRow( column(6, textInput(&quot;stock4&quot;, &quot;Stock 4&quot;, &quot;EEM&quot;)), column(5, numericInput(&quot;w4&quot;, &quot;Portf. %&quot;, 20, min = 1, max = 100)) ) fluidRow( column(6, textInput(&quot;stock5&quot;, &quot;Stock 5&quot;, &quot;AGG&quot;)), column(5, numericInput(&quot;w5&quot;, &quot;Portf. %&quot;, 10, min = 1, max = 100)) ) FIGURE 3.2: Asset and Weights Input Fields It’s worth a second look at this code to make sure it’s clear becuase we will be reusing it verbatim and making no apologies. Let’s dissect one of those fluid rows line-by-line. fluidRow() creates the row. column(6...) creates a column for our stock ticker input with a length of 6. textInput(&quot;stock1&quot;, &quot;Stock 1&quot;, &quot;SPY&quot;)) creates our first text input field. We called it stock1 which means it will be referenced in downstream code as input$stock1. We labeled it with “Stock 1”, which is what the end user will see when viewing the app. Finally we set “SPY” as the default initial value. We also want a row where the user can choose a start date with dateInput(&quot;date&quot;, &quot;Starting Date&quot;, &quot;2010-01-01&quot;, format = &quot;yyyy-mm-dd&quot;)). fluidRow( column(7, dateInput(&quot;date&quot;, &quot;Starting Date&quot;, &quot;2010-01-01&quot;, format = &quot;yyyy-mm-dd&quot;)) ) The dateInput() is also quite important as we will use it in our future Shiny apps. Finally, let’s give the user the ability to rebalance the portfolio at different intervals. We will use selectInput(&quot;rebalance&quot;, &quot;rebal freq&quot;, c(&quot;Yearly&quot; = &quot;years&quot;, &quot;Monthly&quot; = &quot;months&quot;, &quot;Weekly&quot; = &quot;weeks&quot;)) to create a drop down for the user. fluidRow( column(6, selectInput(&quot;rebalance&quot;, &quot;rebal freq&quot;, c(&quot;Yearly&quot; = &quot;years&quot;, &quot;Monthly&quot; = &quot;months&quot;, &quot;Weekly&quot; = &quot;weeks&quot;)) ) ) Finally, we include a submit button for our end user. This button is what takes all those inputs and passes them on to our reactive functions so the Shiny engine can start doing its work. The app won’t fire until the user clicks submit. actionButton(&quot;go&quot;, &quot;Submit&quot;) Here is what the entire input sidebar looks like: FIGURE 3.3: Input Sidebar The ‘submit’ button is hugely important button because it enables the use of eventReactive() to control our computation. That first eventReaactive() is where we take the user-chosen stocks and grab their daily prices. The code should look very familiar from our previous work, except it depends on inputs from the user for ticker symbols, weights and starting date. portfolio_returns_byhand &lt;- eventReactive(input$go, { symbols &lt;- c(input$stock1, input$stock2, input$stock3, input$stock4, input$stock5) prices &lt;- getSymbols(symbols, src = &#39;yahoo&#39;, from = input$date, auto.assign = TRUE, warnings = FALSE) %&gt;% map(~Ad(get(.))) %&gt;% reduce(merge) %&gt;% `colnames&lt;-`(symbols) w &lt;- c(input$w1/100, input$w2/100, input$w3/100, input$w4/100, input$w5/100) asset_returns_long &lt;- prices %&gt;% to.monthly(indexAt = &quot;last&quot;, OHLC = FALSE) %&gt;% tk_tbl(preserve_index = TRUE, rename_index = &quot;date&quot;) %&gt;% gather(asset, returns, -date) %&gt;% group_by(asset) %&gt;% mutate(returns = (log(returns) - log(lag(returns)))) portfolio_returns_byhand &lt;- asset_returns_long %&gt;% tq_portfolio(assets_col = asset, returns_col = returns, weights = w, col_rename = &quot;returns&quot;) }) We now have an object called portfolio_returns_byhand() and we can pass that object to our downstream code chunks. In fact, our substantive work has been completed. What’s left is to display the distributions of portfolio returns, which we did in our previous work by passing a dataframe object to ggplot. Shiny works in a similar way but it also uses a custom function for building reactive charts called renderPlot(). By including renderPlot() in the code chunks, we are alerting the app that a reactive plot is being built, one that will change when the an upstream reactive or input changes. In this case, the plot will change when the user clicks ‘submit’ and fires off the eventReactive(). After calling renderPlot(), we use ggplot() to create a scatter plot, a histogram and a density chart of monthly returns. These will be nested in different tabs so the user can toggle between them and choose which is most helpful. That might a bit hard to envision so here’s a snapshot: FIGURE 3.4: Tabs from Shiny App The flow for these 3 ggplot code chunks, which appear in the different tabs, is going to be the same: call the reactive function renderPlot(), pass inportfolio_returns_byhand(), call ggplot() with an aes(x = ...) argument and then choose the appropriate geom_. The specifics of the geom_ and other aesthetics are taken straight from our previous visualizations. Here is the scatterplot code chunk. renderPlot({ portfolio_returns_byhand() %&gt;% ggplot(aes(x = date)) + geom_point(aes(y = returns), color = &quot;cornflowerblue&quot;) + ylab(&quot;percent monthly returns&quot;) }) Here is the histogram code chunk. renderPlot({ portfolio_returns_byhand() %&gt;% ggplot(aes(x = returns)) + geom_histogram(alpha = 0.25, binwidth = .01, fill = &quot;cornflowerblue&quot;) }) And finally here is the density chart code chunk. renderPlot({ portfolio_returns_byhand() %&gt;% ggplot(aes(x = returns)) + stat_density(geom = &quot;line&quot;, size = 1, color = &quot;cornflowerblue&quot;) }) Again, the final app and full source code can be seen here: www.reproduciblefinance.com/shiny/returns-distribution/ This Shiny app is a good way to take all that grinding we did on portfolio returns and allow an end user to apply it to a custom portfolio. "],
["growth-of-a-dollar.html", "Chapter 4 Growth of a dollar", " Chapter 4 Growth of a dollar We have covered the process of importing daily price data for 5 assets, converting to monthly log returns for those assets, and then converting to portfolio returns after assigning weights to those assets. Next we want to convert those portfolio returns to the growth of a dollar over time, so that each month’s observation is not a monthly return but rather how a dollar invested would have grown cumulatively. One method for this calculation is to add 1 to our monthly returns and take the cumulative product. portfolio_growth_byhand &lt;- cumprod(1 + portfolio_returns_byhand$returns) tail(portfolio_growth_byhand) ## returns ## 2017-07-31 1.392620 ## 2017-08-31 1.393579 ## 2017-09-29 1.430683 ## 2017-10-31 1.456039 ## 2017-11-30 1.478898 ## 2017-12-29 1.498779 That cumprod(1 + returns) is what the built-in functions will be handling for us under the hood but we will go through them all to be sure they match and discover new code flows. Portfolio Growth in the xts World Let’s turn to the xts world, where our first method is translate directly from asset returns to portfolio growth with the same Return.portfolio() function as we used to calculate portfolio returns. The difference from before is that we include the argument wealth.index = 1. This tells the function to calculate the growth of a dollar, as if our wealth started at $1 invested. portfolio_growth_xts_skip_step &lt;- Return.portfolio(asset_returns_xts, wealth.index = 1, weights = w, rebalance_on = &quot;months&quot;) %&gt;% `colnames&lt;-`(&quot;growth&quot;) tail(portfolio_growth_xts_skip_step) ## growth ## 2017-07-31 1.392620 ## 2017-08-31 1.393579 ## 2017-09-29 1.430683 ## 2017-10-31 1.456039 ## 2017-11-30 1.478898 ## 2017-12-29 1.498779 The second method makes use of the portfolio returns object that we calculated earlier. We take the object portfolio_returns_xts_rebalanced_monthly and pass it to Return.portfolio(). We don’t need to supply weights but we do again set wealth.index = 1. portfolio_growth_xts_rebalanced_monthly &lt;- Return.portfolio(portfolio_returns_xts_rebalanced_monthly, wealth.index = 1) %&gt;% `colnames&lt;-`(&quot;growth&quot;) These two methods yield the same result for the growth of a dollar in our portfolio. tail(portfolio_growth_xts_skip_step) ## growth ## 2017-07-31 1.392620 ## 2017-08-31 1.393579 ## 2017-09-29 1.430683 ## 2017-10-31 1.456039 ## 2017-11-30 1.478898 ## 2017-12-29 1.498779 tail(portfolio_growth_xts_rebalanced_monthly) ## growth ## 2017-07-31 1.392620 ## 2017-08-31 1.393579 ## 2017-09-29 1.430683 ## 2017-10-31 1.456039 ## 2017-11-30 1.478898 ## 2017-12-29 1.498779 At first glance, the first method might seem to be better. It is more concise because we skip the step of converting asset returns to portfolio returns. But that skipping has a cost because we no longer have an object of monthly portfolio returns, and that means we cannot visualize those returns or calculate their standard deviations, skewness etc. Maybe that’s not important to our project, or maybe it’s crucial. Either way, be aware that skipping the step of calculating monthly asset returns means we can’t work with those returns. Portfolio Growth in the Tidyverse We have object of returns stored as portfolio_returns_dplyr_byhand and we can use that call to cumprod(1 + port_returns) along with mutate() to calculate growth of a dollar. I want to keep only the growth calculation so will delete the portfolio returns column with select(-port_returns). portfolio_growth_dplyr_byhand &lt;- portfolio_returns_dplyr_byhand %&gt;% mutate(growth = cumprod(1 + port_returns)) %&gt;% select(-port_returns) tail(portfolio_growth_dplyr_byhand) ## # A tibble: 6 x 2 ## date growth ## &lt;date&gt; &lt;dbl&gt; ## 1 2017-07-31 1.39 ## 2 2017-08-31 1.39 ## 3 2017-09-29 1.43 ## 4 2017-10-31 1.46 ## 5 2017-11-30 1.48 ## 6 2017-12-29 1.50 Portfolio Growth in the tidyquant World On to a tidyquant method for calculating growth of a dollar. Very similar to the xts method, we can go direct from asset returns to portfolio growth with the following code chunk. We use the tq_portfolio() function, pass it asset_returns_long, along with a weights vector and wealth.index = 1. portfolio_growth_tq_rebalanced_monthly &lt;- asset_returns_long %&gt;% tq_portfolio(assets_col = asset, returns_col = returns, weights = w, col_rename = &quot;growth&quot;, rebalance_on = &quot;months&quot;, wealth.index = 1) That method again skipped our important step of first finding monthly returns. Maybe we are fine with that as long as we are aware of it. For the sake of fun, let’s combine the tidyverse and tidyquant for a code flow that still relies on those monthly returns. We will use mutate() from the dplyr package and create a new column called ’growth with mutate(growth = cumprod(1 + returns)). portfolio_growth_tidy_tq_combined &lt;- portfolio_returns_tq_rebalanced_monthly %&gt;% mutate(growth = cumprod(1 + returns)) %&gt;% select(-returns) Have a look at our results thus far. tail(portfolio_growth_byhand) ## returns ## 2017-07-31 1.392620 ## 2017-08-31 1.393579 ## 2017-09-29 1.430683 ## 2017-10-31 1.456039 ## 2017-11-30 1.478898 ## 2017-12-29 1.498779 tail(portfolio_growth_dplyr_byhand) ## # A tibble: 6 x 2 ## date growth ## &lt;date&gt; &lt;dbl&gt; ## 1 2017-07-31 1.39 ## 2 2017-08-31 1.39 ## 3 2017-09-29 1.43 ## 4 2017-10-31 1.46 ## 5 2017-11-30 1.48 ## 6 2017-12-29 1.50 tail(portfolio_growth_tq_rebalanced_monthly) ## # A tibble: 6 x 2 ## date growth ## &lt;date&gt; &lt;dbl&gt; ## 1 2017-07-31 1.39 ## 2 2017-08-31 1.39 ## 3 2017-09-29 1.43 ## 4 2017-10-31 1.46 ## 5 2017-11-30 1.48 ## 6 2017-12-29 1.50 tail(portfolio_growth_tidy_tq_combined) ## # A tibble: 6 x 2 ## date growth ## &lt;date&gt; &lt;dbl&gt; ## 1 2017-07-31 1.39 ## 2 2017-08-31 1.39 ## 3 2017-09-29 1.43 ## 4 2017-10-31 1.46 ## 5 2017-11-30 1.48 ## 6 2017-12-29 1.50 tail(portfolio_growth_xts_rebalanced_monthly) ## growth ## 2017-07-31 1.392620 ## 2017-08-31 1.393579 ## 2017-09-29 1.430683 ## 2017-10-31 1.456039 ## 2017-11-30 1.478898 ## 2017-12-29 1.498779 Before we move on to Shiny, let’s explore one more method using the purrr package from the tidyverse. purrr contains a lot of useful functions and the map() family is the most commonly used (we will cover it later on), but another powerful function is accumulate(). As the name implies, this function allows us to accumulate calculations in a recursive way, meaning we can use prior calculations the same way we would with cumprod(). We will make use of this when we get to Monte Carlo simulations. portfolio_growth_purrr &lt;- portfolio_returns_tq_rebalanced_monthly %&gt;% mutate(growth_1 = accumulate(1 + returns, `*`), growth_2 = accumulate(1 + returns, function(x, y) x * y)) %&gt;% select(date, growth_1, growth_2) Note that we used accumulate() in two ways: accumulate(1 + returns, *) and accumulate(1 + returns, function(x, y) x * y). That is two new ways to calculate growth but in general it demonstrates a nice way to introduce a new package and new function to our team’s toolkit. When we introducing a new functiona or package, most important is to explicitly flag it and explain it. Without that, our collaborators might miss the new function or package altogether, especially if it is an internal package. Next, when possible, use the new tool to accomplish a task that we also have accomplished in a well-known way. Here, we introduce accumulate() to calculate growth of a dollar, having already done so with cumprod() and built-ins from PerformanceAnalytics and tidyquant. We have created a familiar environment in which to introduce a new tool and if in the future we use that tool in a complex environment (as we will when running Monte Carlo simulations), our collaborators will have got a prior introduction. As a sanity check for all these methods, let’s run a final comparison. final_comparison &lt;- merge.xts(portfolio_growth_byhand, portfolio_growth_xts_skip_step, portfolio_growth_xts_rebalanced_monthly) %&gt;% tk_tbl(preserve_index = TRUE, rename_index = &quot;date&quot;) %&gt;% bind_cols(portfolio_growth_dplyr_byhand) %&gt;% select(-date1) %&gt;% bind_cols(portfolio_growth_tq_rebalanced_monthly) %&gt;% select(-date1) %&gt;% bind_cols(portfolio_growth_tidy_tq_combined) %&gt;% select(-date1) %&gt;% bind_cols(portfolio_growth_purrr) %&gt;% select(-date1) %&gt;% `colnames&lt;-`(c(&quot;date&quot;, &quot;by_hand&quot;, &quot;xts1&quot;, &quot;xts2&quot;, &quot;dplyr&quot;, &quot;tq&quot;, &quot;tidy_tq&quot;, &quot;purrr1&quot;, &quot;purrr2&quot;)) head(final_comparison) ## # A tibble: 6 x 9 ## date by_hand xts1 xts2 dplyr tq tidy_tq purrr1 purrr2 ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013-02-28 0.999 0.999 0.999 0.999 0.999 0.999 0.999 0.999 ## 2 2013-03-28 1.02 1.02 1.02 1.02 1.02 1.02 1.02 1.02 ## 3 2013-04-30 1.04 1.04 1.04 1.04 1.04 1.04 1.04 1.04 ## 4 2013-05-31 1.03 1.03 1.03 1.03 1.03 1.03 1.03 1.03 ## 5 2013-06-28 1.01 1.01 1.01 1.01 1.01 1.01 1.01 1.01 ## 6 2013-07-31 1.05 1.05 1.05 1.05 1.05 1.05 1.05 1.05 tail(final_comparison) ## # A tibble: 6 x 9 ## date by_hand xts1 xts2 dplyr tq tidy_tq purrr1 purrr2 ## &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2017-07-31 1.39 1.39 1.39 1.39 1.39 1.39 1.39 1.39 ## 2 2017-08-31 1.39 1.39 1.39 1.39 1.39 1.39 1.39 1.39 ## 3 2017-09-29 1.43 1.43 1.43 1.43 1.43 1.43 1.43 1.43 ## 4 2017-10-31 1.46 1.46 1.46 1.46 1.46 1.46 1.46 1.46 ## 5 2017-11-30 1.48 1.48 1.48 1.48 1.48 1.48 1.48 1.48 ## 6 2017-12-29 1.50 1.50 1.50 1.50 1.50 1.50 1.50 1.50 8 routes to the same results for dollar growth! A lot of grinding but should any of our colleagues wish to reproduce, resuse or extend our results, a plethora of code paths is available to them. Why might those paths be important? On a team of 10 R/finance ninjas, there’s a good chance that one coder will prefer the xts world, one will prefer tidyquant and/or one will prefer the tidyverse and hand-rolled functions. It’s not the case that every document needs to include all these different paths but it’s good practice to have one file in the team’s library that can be used as a global reference point. If language analogies are appealing, we can think of this as a Rosetta Script or where to turn when someone wonders what’s the equivalent of this analytical path using another set of packages. Beyond the flexibility of different code paths, the various object structures lend themselves to different visualizations techniques, which is a reason that some coders might prefer different paths. Visualizing Portfolio Growth We start again in the xts world via highcharter. The first two lines shoule like familiar from our previous charts. Let’s add more aesthetics. I want a title and add it with hc_title(text = &quot;Growth of a Dollar&quot;) and the y-axis label to be on left-hand side with a $ sign. We add that with hc_yAxis(title = list(text = &quot;growth of dollar&quot;), opposite = FALSE, labels = list(format = &quot;${value}&quot;). highchart(type = &quot;stock&quot;) %&gt;% hc_add_series(portfolio_growth_xts_rebalanced_monthly, name = &quot;Portfolio&quot;, color = &quot;cornflowerblue&quot;, lineWidth = 1) %&gt;% hc_title(text = &quot;Growth of a Dollar&quot;) %&gt;% hc_yAxis(title = list(text = &quot;growth of dollar&quot;), opposite = FALSE, labels = list(format = &quot;${value}&quot;)) %&gt;% hc_add_theme(hc_theme_flat()) %&gt;% hc_navigator(enabled = FALSE) %&gt;% hc_scrollbar(enabled = FALSE) That’s a nice and efficient chart. An end user can quickly discern what would have happened to a dollar over time. We can also use ggplot() for time series plotting if we wish to stay in the tidy world. We start with the object portfolio_growth_purrr, and set our date column as the x-axis and growth_1 as the y-axis by calling ggplot(aes(x = date, y = growth_1)). We will add a $ sign to the y-axis label with scale_y_continuous(breaks = pretty_breaks(n = 10), labels = dollar) which requires loading the scales package. library(scales) portfolio_growth_purrr %&gt;% ggplot(aes(x = date, y = growth_1)) + geom_line(colour = &quot;cornflowerblue&quot;) + ylab(&quot;dollar growth&quot;) + xlab(&quot;month&quot;) + ggtitle(&quot;Growth of a Dollar&quot;) + scale_y_continuous(breaks = pretty_breaks(n = 10), labels = dollar) + scale_x_date(breaks = pretty_breaks(n = 10)) The end results with ggplot or highcharter look similar though highcharter offers a bit more interactivity and the built-in date selection buttons. 4.0.1 Shiny Growth of a Dollar Now we want to port our dollar growth work to a Shiny application so that an end user is able to: choose tickers and portfolio weights choose a start date choose a rebalancing frequency chart the growth of a dollar in the portfolio since the chosen start date The final app can be seen here with full source code: www.reproduciblefinance.com/shiny/portfolio-growth/ FIGURE 4.1: Portfolio Growth Shiny The input sidebar is identical to that of our app on returns distribtution. We let the user choose 5 ticker symbols, 5 weights, a start date and rebalance period. The user then clicks ‘submit’ to fire up the reactives. Since it’s identical, we’re not going to review it here. We will, though, review the difference substantive flow that is used to get portfolio growth. We use an eventReactive(), pass in tickers, weights, start date and frequency, but instead of calculating portfolio returns, we calculate portfolio growth. It’s not a copy paste from our first app, but it’s a similar structure. Since we use highcharter in this app, we go with the xts world and use Return.portfolio(asset_returns_xts, wealth.index = 1,...) - this is the same method we used in our previous growth calculation. portfolio_growth_xts &lt;- eventReactive(input$go, { symbols &lt;- c(input$stock1, input$stock2, input$stock3, input$stock4, input$stock5) prices &lt;- getSymbols(symbols, src = &#39;yahoo&#39;, from = input$date, auto.assign = TRUE, warnings = FALSE) %&gt;% map(~Ad(get(.))) %&gt;% reduce(merge) %&gt;% `colnames&lt;-`(symbols) w &lt;- c(input$w1/100, input$w2/100, input$w3/100, input$w4/100, input$w5/100) prices_monthly &lt;- to.monthly(prices, indexAt = &quot;last&quot;, OHLC = FALSE) asset_returns_xts &lt;- na.omit(Return.calculate(prices_monthly, method = &quot;log&quot;)) portfolio_growth_xts &lt;- Return.portfolio(asset_returns_xts, wealth.index = 1, weights = w, rebalance_on = input$rebalance) %&gt;% `colnames&lt;-`(&quot;growth&quot;) }) At this point, portfolio growth is calculated and stored as portfolio_growth_xts() and our substantive work has been completed. Now we want to display the chart of the portfolio growth over time. Outside of Shiny, this would be a simple passing of the xts object to highcharter. As with ggplot, Shiny uses a custom function for building reactive highcharter charts called renderHighchart(). Once we invoke that renderHighchart(), our code looks very similar to our previous visualization work as we use hc_add_series(portfolio_growth_xts(), name = &quot;Dollar Growth&quot;, color = &quot;cornflowerblue&quot;) to add our portfolio growth xts object to a chart. renderHighchart({ highchart(type = &quot;stock&quot;) %&gt;% hc_title(text = &quot;Growth of a Dollar&quot;) %&gt;% hc_add_series(portfolio_growth_xts(), name = &quot;Dollar Growth&quot;, color = &quot;cornflowerblue&quot;) %&gt;% hc_navigator(enabled = FALSE) %&gt;% hc_scrollbar(enabled = FALSE) }) Next, we use ggplot() to create the same visual as above but in the tidy world. The code flow is quite similar to how we would normally create a line chart, except we first need to convert our xts object to a tibble with the tk_tbl(preserve_index = TRUE, rename_index = &quot;date&quot;). The tk_tbl() function is from the timetk package but is part of the tidyquant universe. After converting from xts to a data frame, we make our call to ggplot(aes(x = date)) and add a geom with geom_line(aes(y = growth), color = &quot;cornflowerblue&quot;). Note that the renderPlot() function is playing the same role as renderHighchart() above - it is alerting the Shiny app that a reactive plot is forthcoming after user inputs, instead of a static plot that is unchanging. renderPlot({ portfolio_growth_xts() %&gt;% tk_tbl(preserve_index = TRUE, rename_index = &quot;date&quot;) %&gt;% ggplot(aes(x = date) + geom_line(aes(y = growth), color = &quot;cornflowerblue&quot;) + ylab(&quot;dollars&quot;) + ggtitle(&quot;Growth of Dollar over time&quot;) }) Here is another snapshot of what the app looks like with the visualizations. FIGURE 4.2: Portfolio Growth Shiny Concluding That concludes our work on portolio returns and growth. From a general data science paradigm perspective, we can think of this as mapping onto data import, wrangling and transformation where: pulling daily prices from yahoo! Finance = data import isolating adjusted prices and converting to monthly prices = data wrangling converting to log returns, portfolio returns, portfolio growth = data transformation We were painstaking about our process to provide our selves and collaborators with a nice data provenance, plus a variety of code paths for visualizing. In the following sections, we will see how having several foundational objects for portfolio returns and growth assist our more analytical work. Make sure the data frames and xts objects are familiar and intuitive because we will use them throughout the rest of the book but will assume that their structure and derivation were explained here in Section 1. "]
]
