[
["portfolio-theory.html", "Portfolio Theory", " Portfolio Theory In this section we will devote four chapters to the relationship between risk and return, or what I think of as a simplified introduction to Modern Portfolio Theory. As with volatility/risk, we will not delve deep into the theory of these concepts but instead will focus on readable, reproducible workflows using different R objects and packages. If you wish to delve further into these topics, have a look at BKM and Eric Zivot’s new book. Or, go back to the source and fire up Harry Markowitz’s 1959 monograph, “Portfolio Selection: Efficient Diversification of Investments”1. Sortino’s original paper &quot; and William Sharpe’s “”. Up until now, we have been looking at returns in isolation and risk in isolation, without regard to how the two are related. This section will focus on their relationship, how to measure it, how to think about, how to visualize it. First, we will discuss the Sharpe Ratio and the Sortino Ratio, two measures of the return/risk ratio of a portfolio. Then, we will look at the Capital Asset Pricing Model and specifically how to calculate the market beta for our assets and portfolio. This will be an introduction to simple linear regression as well. We will conclude with an exploration of the Fama French factor model and an introduction to multiple linear regressoin. The world of portfolio theory is vast and far reaching and we are focusing on four small corners of that world, but Sharpe and Sortino are important ratio and CAPM-FF are iconic. We are focusing on the foundational but hopefully it lays the ground work for more complex work in your future. Markowitz, Harry. Portfolio Selection: Efficient Diversification of Investments, John Wiley &amp; Sons, 1959↩ "],
["sharpe-ratio.html", "Chapter 2 Sharpe Ratio", " Chapter 2 Sharpe Ratio ## ── Attaching packages ───────────────────────────────────────────────────────────── tidyverse 1.2.1 ── ## ✔ ggplot2 2.2.1 ✔ purrr 0.2.4 ## ✔ tibble 1.4.1 ✔ dplyr 0.7.4 ## ✔ tidyr 0.7.2 ✔ stringr 1.2.0 ## ✔ readr 1.1.1 ✔ forcats 0.2.0 ## Warning: package &#39;ggplot2&#39; was built under R version 3.4.3 ## Warning: package &#39;readr&#39; was built under R version 3.4.3 ## Warning: package &#39;stringr&#39; was built under R version 3.4.3 ## Warning: package &#39;forcats&#39; was built under R version 3.4.3 ## ── Conflicts ──────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## Loading required package: lubridate ## ## Attaching package: &#39;lubridate&#39; ## The following object is masked from &#39;package:base&#39;: ## ## date ## Loading required package: PerformanceAnalytics ## Loading required package: xts ## Loading required package: zoo ## ## Attaching package: &#39;zoo&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## as.Date, as.Date.numeric ## ## Attaching package: &#39;xts&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## first, last ## ## Attaching package: &#39;PerformanceAnalytics&#39; ## The following object is masked from &#39;package:graphics&#39;: ## ## legend ## Loading required package: quantmod ## Loading required package: TTR ## Version 0.4-0 included new data defaults. See ?getSymbols. ## ## Attaching package: &#39;tidyquant&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## as_tibble ## The following object is masked from &#39;package:tibble&#39;: ## ## as_tibble ## ## Attaching package: &#39;tibbletime&#39; ## The following object is masked from &#39;package:stats&#39;: ## ## filter ## Highcharts (www.highcharts.com) is a Highsoft software product which is ## not free for commercial and Governmental use ## ## Attaching package: &#39;scales&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## discard ## The following object is masked from &#39;package:readr&#39;: ## ## col_factor We start out journey into portfolio theory with an investigation of the Sharpe Ratio. Briefly, the Sharpe Ratio is the mean of the excess portfolio returns above the risk-free rate, divided by the standard deviation of the excess monthly returns above the risk-free rate. This is the formulation of the Sharpe Ratio as of 1994; if we wished to use the original formulation from 1966 the denominator would be the standard deviation of portfolio monthly returns. Learn more here: web.stanford.edu/~wfsharpe/art/sr/sr.htm. In other words, the Sharpe Ratio measures excess returns per unit of volatility, where we take the standard deviation to represent portfolio volatility. The Sharpe Ratio was brought to us by Bill Sharpe - arguably the most important economist for modern investment management as the creator of the Sharpe Ratio, CAPM (which we will cover later) and Financial Engines, a forerunner of today’s robo-advisor movement. The Latex code for the Sharpe Ratio equation is as follows $$Sharpe~Ratio={(\\overline{R_{p}-R_{f}})}/\\sigma_{excess}$$ And here is the output \\[Sharpe~Ratio={(\\overline{R_{p}-R_{f}})}/\\sigma_{excess}\\] The numerator is the mean excess return above the risk free rate and the numerator is the standard deviation of those excess returns. In other words, it’s a ratio of return to risk and so a higher Sharpe Ratio indicates a ‘better’ portfolio. When working with the Sharpe Ratio, we have two critical choices: how to construct the portfolio using assets and weights, and which risk free to use. We’ve already chosen a portfolio and analyzed it’s risk and return, so that leaves a risk free rate. Let’s go with .03%. If you don’t like that one, please substitute and experiment at will! Let’s assign the risk free rate to a variable called rfr. rfr &lt;- .0003 Sharpe Ratio in the xts world Calculating the Sharpe Ratio in the xts world is almost depressingly convenient. We call SharpeRatio(portfolio_returns_xts, Rf = rfr), passing our portfolio returns and risk-free rate to the built-in function from PerformanceAnalytics. sharpe_xts &lt;- SharpeRatio(portfolio_returns_xts_rebalanced_monthly, Rf = rfr) %&gt;% `colnames&lt;-`(&quot;ratio&quot;) From a substantive perspective, we could stop here and start visualizing with highcharter. But we’re not going do that! Let’s head to the tidyverse. Sharpe Ration in the Tidyverse For our tidyverse example, let’s use a by-hand calculation and implement it via pipes and dplyr. We call start with our object portfolio_returns_dplyr_byhand and then invoke summarise(ratio = mean(returns - rfr)/sd(returns - rfr)). sharpe_tidyverse_byhand &lt;- portfolio_returns_dplyr_byhand %&gt;% summarise(ratio = mean(returns - rfr)/sd(returns - rfr)) sharpe_tidyverse_byhand$ratio ## [1] 0.2599818 Shape Ratio with Tidyquant Now on to tidyquant, which allows us to apply the SharpeRatio() function from PerformanceAnalytics to a tibble. sharpe_tq &lt;- portfolio_returns_tq_rebalanced_monthly %&gt;% tq_performance(Ra = returns, performance_fun = SharpeRatio, Rf = rfr) %&gt;% select(2) %&gt;% `colnames&lt;-`(&quot;ratio&quot;) Let’s compare our 3 Sharpe objects. sharpe_xts[1] ## [1] 0.2599818 sharpe_tidyverse_byhand$ratio ## [1] 0.2599818 sharpe_tq$ratio ## [1] 0.2599818 We have consistent results from xts, tidyquant and our by-hand piped calculation. One issue with the Sharpe Ratio is that it’s most useful in comparison to other Sharpe Ratios. Is our portfolio’s Sharpe good, great, awful? Let’s compare it to the Sharpe Ratio of the S&amp;P500 in the same time period. market_returns_xts &lt;- getSymbols(&quot;SPY&quot;, src = &#39;yahoo&#39;, from = &quot;2013-01-01&quot;, to = &quot;2017-12-31&quot;, auto.assign = TRUE, warnings = FALSE) %&gt;% map(~Ad(get(.))) %&gt;% reduce(merge) %&gt;% `colnames&lt;-`(&quot;SPY&quot;) %&gt;% to.monthly(indexAt = &quot;last&quot;, OHLC = FALSE) ## &#39;getSymbols&#39; currently uses auto.assign=TRUE by default, but will ## use auto.assign=FALSE in 0.5-0. You will still be able to use ## &#39;loadSymbols&#39; to automatically load data. getOption(&quot;getSymbols.env&quot;) ## and getOption(&quot;getSymbols.auto.assign&quot;) will still be checked for ## alternate defaults. ## ## This message is shown once per session and may be disabled by setting ## options(&quot;getSymbols.warning4.0&quot;=FALSE). See ?getSymbols for details. ## ## WARNING: There have been significant changes to Yahoo Finance data. ## Please see the Warning section of &#39;?getSymbols.yahoo&#39; for details. ## ## This message is shown once per session and may be disabled by setting ## options(&quot;getSymbols.yahoo.warning&quot;=FALSE). market_sharpe &lt;- market_returns_xts %&gt;% tk_tbl(preserve_index = TRUE, rename_index = &quot;date&quot;) %&gt;% mutate(returns = (log(SPY) - log(lag(SPY)))) %&gt;% na.omit() %&gt;% summarise(ratio = mean(returns - rfr)/sd(returns - rfr)) market_sharpe$ratio ## [1] 0.414671 Uh oh, our portfolio has underperfomed the market - all of work for nothing! What might explain this? It’s been 5 years of inexorably bullish market behavior and that makes it hard to outperform. In any event, let’s visualize!. Visualizing Sharpe Ratios First, we will get a sense for what proportion of our portfolio returns exceeded the risk-free rate. When we originally calculated Sharpe by-hand in the tidy world, we used summarise to create one new cell for our end result. The code was summarise(ratio = mean(returns - rfr)/sd(returns - rfr)). Now, we will make two additions to assist in our data visualization. We will add a column for returns that fall below the risk-free rate with mutate(returns_below_rfr = ifelse(returns &lt; rfr, returns, NA)) and add a column for returns above the risk-free rate with mutate(returns_above_rfr = ifelse(returns &gt; rfr, returns, NA)). This is not necessary for calculating the Sharpe Ratio, but we will see how it makes our ggplotting a bit easier and it illustrates a benefit of doing things by-hand with dplyr: if we want to extract or create certain data tranformations, we can add it to the piped code flow. sharpe_byhand_with_return_columns &lt;- portfolio_returns_tq_rebalanced_monthly %&gt;% mutate(ratio = mean(returns - rfr)/sd(returns - rfr)) %&gt;% mutate(returns_below_rfr = ifelse(returns &lt; rfr, returns, NA)) %&gt;% mutate(returns_above_rfr = ifelse(returns &gt; rfr, returns, NA)) Let’s start with a scatterplot of returns using ggplot. The goal is to quickly grasp how many of our returns are above the rfr and how many are below the rfr. We will create green points for returns above rfr with geom_point(aes(y = returns_above_rfr), colour = &quot;green&quot;) and red points for returns below rfr with geom_point(aes(y = returns_below_rfr), colour = &quot;red&quot;). I’m always curious how portfolios have performed since the election so we’ll add a blue vertical line at November of 2016. We will also include a horizontal purple dotted line at the rfr. sharpe_byhand_with_return_columns %&gt;% ggplot(aes(x = date)) + geom_point(aes(y = returns_below_rfr), colour = &quot;red&quot;) + geom_point(aes(y = returns_above_rfr), colour = &quot;green&quot;) + geom_vline(xintercept = as.numeric(as.Date(&quot;2016-11-30&quot;)), color = &quot;blue&quot;) + geom_hline(yintercept = rfr, color = &quot;purple&quot;, linetype = &quot;dotted&quot;) + annotate(geom = &quot;text&quot;, x = as.Date(&quot;2016-11-30&quot;), y = -.04, label = &quot;Election&quot;, fontface = &quot;plain&quot;, angle = 90, alpha = .5, vjust = 1.5) + ylab(&quot;percent monthly returns&quot;) + scale_y_continuous(breaks = pretty_breaks(n = 10)) Next we will build a histogram of the distribution of returns with geom_histogram(alpha = 0.25, binwidth = .01, fill = &quot;cornflowerblue&quot;). We will again add a line for the risk-free rate. sharpe_byhand_with_return_columns %&gt;% ggplot(aes(x = returns)) + geom_histogram(alpha = 0.25, binwidth = .01, fill = &quot;cornflowerblue&quot;) + geom_vline(xintercept = rfr, color = &quot;green&quot;) + annotate(geom = &quot;text&quot;, x = rfr, y = 15, label = &quot;rfr&quot;, fontface = &quot;plain&quot;, angle = 90, alpha = .5, vjust = 1) Interesting to see the distribution of returns in comparison to the risk-free rate, but we have not visualized the actual Sharpe Ratio yet. We will do so now. The ratio itself is one number. Similar to the standard deviation, skewness and kurtosis of returns, that doesn’t allow much by way of dynamic visualization and it might obscure important periods of fluctutation in our data. We can solve that by working with the rolling Sharpe Ratio. Rolling Sharpe Ratio in the xts World First, we need to calculate the rolling 6-month Sharpe Ratio with rollapply(portfolio_returns_xts_rebalanced_monthly, 6, function(x) SharpeRatio(x, Rf = rfr, FUN = &quot;StdDev&quot;)). Note that we need to pass in the argument FUN = &quot;StdDev&quot;. Try running the code without that argument check out the error. window &lt;- 6 rolling_sharpe_xts &lt;- rollapply(portfolio_returns_xts_rebalanced_monthly, window, function(x) SharpeRatio(x, Rf = rfr, FUN = &quot;StdDev&quot;)) %&gt;% na.omit() %&gt;% `colnames&lt;-`(&quot;sharpe&quot;) Rolling Sharpe Ratio with Tidyverse + Tibbletime Similar to what we did with the standard deviation, we can combine the tidyverse and tibbletime to run the rolling Sharpe Ratio calculation on our data frame. Here we are going to write our own function with rollify(), but it’s the same function we used above to find the Sharpe Ratio, ratio = mean(returns - rfr)/sd(returns - rfr). Notice we still pass in our rfr and window variables. library(tibbletime) sharpe_roll_6 &lt;- rollify(function(returns) { ratio = mean(returns - rfr)/sd(returns - rfr) }, window = window) rolling_sharpe_tidy_tibbletime &lt;- portfolio_returns_tq_rebalanced_monthly %&gt;% as_tbl_time(index = date) %&gt;% mutate(ratio = sharpe_roll_6(returns)) %&gt;% na.omit() %&gt;% select(-returns) Let’s compare our objects. head(rolling_sharpe_tidy_tibbletime) ## # A time tibble: 6 x 2 ## # Index: date ## date ratio ## &lt;date&gt; &lt;dbl&gt; ## 1 2013-07-31 0.363 ## 2 2013-08-31 0.156 ## 3 2013-09-30 0.301 ## 4 2013-10-31 0.359 ## 5 2013-11-30 0.477 ## 6 2013-12-31 0.786 head(rolling_sharpe_xts) ## sharpe ## 2013-07-31 0.3626407 ## 2013-08-30 0.1555792 ## 2013-09-30 0.3010784 ## 2013-10-31 0.3585765 ## 2013-11-29 0.4772118 ## 2013-12-31 0.7860678 Visualizing the Rolling Sharpe Ratio Let’s start with highcharter and investigate any unusual occurrences. highchart(type = &quot;stock&quot;) %&gt;% hc_title(text = &quot;Rolling Sharpe&quot;) %&gt;% hc_add_series(rolling_sharpe_xts, name = &quot;sharpe&quot;, color = &quot;blue&quot;) %&gt;% hc_navigator(enabled = FALSE) %&gt;% hc_scrollbar(enabled = FALSE) A huge spike in 2017! Recall that the rolling contribution to volatility of EEM spiked in 2017 as well. There seems to be something afoot during those first six-months. Let’s see how the rolling 12-month compares and whether it smooths out these spikes. sharpe_roll_12_xts &lt;- rollapply(portfolio_returns_xts_rebalanced_monthly, 12, function(x) SharpeRatio(x, Rf = rfr, FUN = &quot;StdDev&quot;)) highchart(type = &quot;stock&quot;) %&gt;% hc_title(text = &quot;Rolling sharpe&quot;) %&gt;% hc_add_series(sharpe_roll_12_xts, name = &quot;sharpe 24&quot;, color = &quot;lightgreen&quot;) %&gt;% hc_navigator(enabled = FALSE) %&gt;% hc_scrollbar(enabled = FALSE) There’s still a spike in 2017 but of a smaller magnitude. If we wish to visualize rolling Sharpe with ggplot, we can convert that xts object to a data frame and then pipe on through. sharpe_roll_12_xts %&gt;% tk_tbl(preserve_index = TRUE, rename_index = &quot;date&quot;) %&gt;% rename(rolling_sharpe = returns) %&gt;% ggplot(aes(x = date, y = rolling_sharpe)) + geom_line(color = &quot;cornflowerblue&quot;) ## Warning: Removed 11 rows containing missing values (geom_path). Those rolling charts certainly make our portfolio look attractive but remember, it actually had a lower Sharpe Ratio than the S&amp;P500 over this time period! Let’s compare their rolling ratios. market_sharpe_roll_12_xts &lt;- rollapply(market_returns_xts, 12, function(x) SharpeRatio(x, Rf = rfr, FUN = &quot;StdDev&quot;)) highchart(type = &quot;stock&quot;) %&gt;% hc_title(text = &quot;Rolling sharpe&quot;) %&gt;% hc_add_series(sharpe_roll_12_xts, name = &quot;Portfolio&quot;, color = &quot;cornflowerblue&quot;) %&gt;% hc_add_series(market_sharpe_roll_12_xts, name = &quot;SP500&quot;, color = &quot;green&quot;) %&gt;% hc_navigator(enabled = FALSE) %&gt;% hc_scrollbar(enabled = FALSE) It seems our portfolio underperformed early and outperformed late. Let’s head to Shiny so end users (and ourselves) can build more interesting portfolios and compare to the S&amp;P500. Shiny for Sharpe Ratio On to Shiny and we will stick with our standard template but add a few aesthetics/best practices. Have a quick look at the final app here: www.reproduciblefinance.com/shiny/sharpe-ratio/ And here is a snapshot FIGURE 2.1: Sharpe Ratio Shiny App Notice that we have added two blue value boxes to display the portfolio and market Sharpe Ratios over whatever time period the end user has selected. Do you like those? Despise them? We’ll run through how to build them anyway. Additionally, try setting the asset weights to a number that does not equal 100 and see the error message. We will review how to add these below. But, first, our input sidebar is our standard except the user can choose a risk-free rate. I’ve chosen to handle that by letting the user enter his or her own number but imagine other methods like the ability to choose a T-bill rate. Or perhaps we feel that the risk-free rate should be set and not changeable because it changes how the end user perceives a portfolio so much. Here we use numericInput(&quot;rfr&quot;, &quot;RFR&quot;, .0003, min = 0, max = 1, step = .0002) to let the user choose a risk-free rate. numericInput(&quot;rfr&quot;, &quot;RFR&quot;, .0003, min = 0, max = 1, step = .0002) Now we follow our same flows from above to calculate the rolling Sharpe Ratio. First, let’s assign our risk-free rate and rolling window objects. We also save the prices object as we have done in our previous apps. rfr &lt;- eventReactive(input$go, {input$rfr/100}) window &lt;- eventReactive(input$go, {input$window}) Note that we ask for a risk-free rate percent. Thus, when calculating the reactive, we divide by 100. Next, we call a reactive to calculate the rolling Sharpe Ratio. rolling_portfolio_sharpe_xts &lt;- eventReactive(input$go, { validate(need(input$w1 + input$w2 + input$w3 + input$w4 + input$w5 == 100, &quot;The portfolio weights must sum to 100%!&quot;)) prices &lt;- prices() w &lt;- c(input$w1/100, input$w2/100, input$w3/100, input$w4/100, input$w5/100) rfr &lt;- rfr() window &lt;- window() prices_monthly &lt;- to.monthly(prices, indexAt = &quot;last&quot;, OHLC = FALSE) asset_returns_xts &lt;- na.omit(Return.calculate(prices_monthly, method = &quot;log&quot;)) portfolio_returns_xts_rebalanced_monthly &lt;- Return.portfolio(asset_returns_xts, weights = w, rebalance_on = &quot;months&quot;) rolling_sharpe &lt;- rollapply(portfolio_returns_xts_rebalanced_monthly, window, function(x) SharpeRatio(x, Rf = rfr, FUN = &quot;StdDev&quot;)) }) Note one crucial line in the above reactive, validate(need(input$w1 + input$w2 + input$w3 + input$w4 + input$w5 == 100, &quot;The portfolio weights must sum to 100%!&quot;)). This is where we ensure that the weights sum to 100. Toggle over to the live app and see what happens when the weights don’t sum to 100. FIGURE 2.2: Weights Error Message We haven’t included that in any of our previous apps - because we were introducing new concepts and didn’t want to clutter the code - but it’s a good idea to include any time the user is choosing weights. Now let’s get the Sharpe Ratio stored in a data frame. We’ll use the same object to hold the Sharpe Ratio and returns, same as we did above. This will allow us to use one object in multiple places. portfolio_sharpe &lt;- eventReactive(input$go, { validate(need(input$w1 + input$w2 + input$w3 + input$w4 + input$w5 == 100, &quot;The portfolio weights must sum to 100%!&quot;)) prices &lt;- prices() w &lt;- c(input$w1/100, input$w2/100, input$w3/100, input$w4/100, input$w5/100) rfr &lt;- rfr() portfolio_returns_sharpe &lt;- prices %&gt;% to.monthly(indexAt = &quot;last&quot;, OHLC = FALSE) %&gt;% tk_tbl(preserve_index = TRUE, rename_index = &quot;date&quot;) %&gt;% gather(asset, returns, -date) %&gt;% group_by(asset) %&gt;% mutate(returns = (log(returns) - log(lag(returns)))) %&gt;% tq_portfolio(assets_col = asset, returns_col = returns, weights = w, col_rename = &quot;returns&quot;) %&gt;% slice(-1) %&gt;% mutate(ratio = mean(returns - rfr)/sd(returns - rfr), returns_below_rfr = ifelse(returns &lt; rfr, returns, NA), returns_above_rfr = ifelse(returns &gt; rfr, returns, NA)) }) I like being able to compare to the S&amp;P500 Sharpe, so we’ll also calculate and chart that. The market Sharpe has to be an interactive as well because it still depends on the start date and rolling window chosen by the end user. Have a look at the code chunk below and notice that we save both the market returns and the overall market Sharpe Ratio by using mutate() twice: mutate(returns = (log(SPY) - log(lag(SPY)))) mutate(market_sharpe = mean(returns - rfr)/sd(returns - rfr)). We will use the market_sharpe column in a valueBox() to print the overall market Sharpe Ratio. We will use the returns column to calculate the rolling market Sharpe for charting with Highcharter(). market_returns_sharpe &lt;- eventReactive(input$go, { rfr &lt;- rfr() market_returns_sharpe &lt;- getSymbols(&quot;SPY&quot;, src = &#39;yahoo&#39;, from = input$date, auto.assign = TRUE, warnings = FALSE) %&gt;% map(~Ad(get(.))) %&gt;% reduce(merge) %&gt;% `colnames&lt;-`(&quot;SPY&quot;) %&gt;% to.monthly(indexAt = &quot;last&quot;, OHLC = FALSE) %&gt;% tk_tbl(preserve_index = TRUE, rename_index = &quot;date&quot;) %&gt;% mutate(returns = (log(SPY) - log(lag(SPY)))) %&gt;% na.omit() %&gt;% mutate(market_sharpe = mean(returns - rfr)/sd(returns - rfr)) }) Let’s see how we include the rolling market Sharpe in our time series. First, have a look at the full code chunk: renderHighchart({ validate(need(input$go != 0, &quot;Please choose your portfolio assets, weights, rfr, rolling window and start date and click submit.&quot;)) rfr &lt;- rfr() window &lt;- window() market_returns_xts &lt;- market_returns_sharpe() %&gt;% select(date, returns) %&gt;% tk_xts(date_var = date) rolling_market_sharpe_xts &lt;- rollapply(market_returns_xts, window(), function(x) SharpeRatio(x, Rf = rfr, FUN = &quot;StdDev&quot;)) highchart(type = &quot;stock&quot;) %&gt;% hc_title(text = &quot;Rolling Sharpe&quot;) %&gt;% hc_add_series(rolling_portfolio_sharpe_xts(), name = &quot;Portfolio&quot;, color = &quot;cornflowerblue&quot;) %&gt;% hc_add_series(rolling_market_sharpe_xts, name = &quot;Market&quot;, color = &quot;green&quot;) %&gt;% hc_navigator(enabled = FALSE) %&gt;% hc_scrollbar(enabled = FALSE) }) Before calling the highchart() function, we transform our tidy, data frame market returns to an xts object with market_returns_xts &lt;- market_returns_sharpe() %&gt;% select(date, returns) %&gt;% tk_xts(date_var = date). Then we calculate the rolling ratio with rolling_market_sharpe_xts &lt;- rollapply(market_returns_xts, window(), function(x) SharpeRatio(x, Rf = rfr, FUN = &quot;StdDev&quot;)). We now have two rolling Sharpe Ratio objects. rolling_market_sharpe_xts holds the market rolling ratio and rolling_portfolio_sharpe_xts() holds the portfolio rolling ratio that we calculated above. We could have calculated the rolling market numbers upstream with our other calculations, especially if we wanted the rolling numbers available elsewhere. But since there is no reason to do so, it’s a good idea to get familiar with another place to house calculations. To complete that chunk breakdown, we then pass our two objects to highchart() with hc_add_series(rolling_portfolio_sharpe_xts(), name = &quot;Portfolio&quot;, color = &quot;cornflowerblue&quot;) and hc_add_series(rolling_market_sharpe_xts, name = &quot;Market&quot;, color = &quot;green&quot;). Our rolling visualizations are complete. Now let’s display the overall Sharpe Ratios with two valueBox() displays. We call the renderValueBox() function, isolate the portfolio Sharpe Ratio with portfolio_sharpe &lt;- portfolio_sharpe() %&gt;% summarise(ratio = round(mean(ratio), 4)) and then build with valueBox(value = tags$p(portfolio_sharpe, style = &quot;font-size: 70%;&quot;), color = &quot;primary&quot;). This argument style = &quot;font-size: 70%;&quot; is purely to set the font size. renderValueBox({ portfolio_sharpe &lt;- portfolio_sharpe() %&gt;% summarise(ratio = round(mean(ratio), 4)) valueBox(value = tags$p(portfolio_sharpe, style = &quot;font-size: 70%;&quot;), color = &quot;primary&quot;) }) Repeat the same for the market ratio. renderValueBox({ market_sharpe &lt;- market_returns_sharpe() %&gt;% summarise(ratio = round(mean(market_sharpe), 4)) valueBox(value = tags$p(market_sharpe, style = &quot;font-size: 70%;&quot;), color = &quot;primary&quot;) }) After this, we add a scatterplot and histogram of returns distributions with the same code flow as has been used with our previous Shiny apps, That’s a wrap for our work on the Sharpe Ratio. In the next Chapter, we will see a slight variation of this idea with the Sortino Ratio, and our work on Sharpe Ratios will come in handy. "],
["sortino-ratio.html", "Chapter 3 Sortino Ratio", " Chapter 3 Sortino Ratio The Sortino Ratio is similar to the Sharpe Ratio except that the riskiness of a portfolio is measured by the deviation of returns below a target return, instead of by the standard deviation of all returns. This stands in contradistinction to the Sharpe Ratio, which measures return/risk by the ratio of the returns above the risk free rate divided by the standard deviation of all returns. By way of history, Harry Markowitz, Nobel laureate and father of MPT whom we mentioned in this section’s introduction, noted that downside deviation might be a better measure of risk than the standard deviation of all returns, but its calculation was computationally too expensive2 (it was 1959, if he only he’d had R on his laptop). The Latex code for the Sortino Ratio equation is as follows: $$Sortino~Ratio_{portfolio}=\\frac{(\\overline{Return_{portfolio}-MAR})}{\\sqrt{\\sum_{t=1}^n min(R_t-MAR,~0)^2}/n}$$ And here is the output \\[Sortino~Ratio_{portfolio}=\\frac{(\\overline{Return_{portfolio}-MAR})}{\\sqrt{\\sum_{t=1}^n min(R_t-MAR,~0)^2}/n}\\] The denominator in that equation (called the Downside Deviation, semi-deviation or downside risk) can be thought of as the deviation of the returns that fall below some target rate of return for the portfolio. That target rate is called the Minimum Acceptable Rate, or MAR. The numerator is the mean portfolio return minus the MAR. It can be thought of as excess returns in the same was as the numerator of the Sharpe Ratio, except for Sortino it’s in excess of whateve minimum rate our team (or our clients) choose. Let’s assign the MAR of .8% to the variable MAR. Note that we are holding this portfolio to a higher standard now than we did in the last chapter. MAR &lt;- .008 Just as we reused a lot of our skewness code flow in our kurtosis calculation, we will reuse some Sharpe code flow for the Sortino calculations. Calculating Sortino Ratio in the xts world In the xts world, very similar to the Sharpe Ratio, PerformanceAnalytics makes it quick to calculate Sortino. It’s the same code as we used for Sharpe, except we call the function SortinoRatio() instead of SharpeRatio(), and the argument is MAR = MAR instead of Rf = rfr. sortino_xts &lt;- SortinoRatio(portfolio_returns_xts_rebalanced_monthly, MAR = MAR) %&gt;% `colnames&lt;-`(&quot;ratio&quot;) Calculating Sortino Ratio in the Tidyverse We’ll again head to dplyr and run a by-hand calculation with summarise(ratio = mean(returns - MAR)/sqrt(sum(pmin(returns - MAR, 0)^2)/nrow(.))). This should look familiar from the previous chapter, but with a different equation. sortino_byhand &lt;- portfolio_returns_tq_rebalanced_monthly %&gt;% summarise(ratio = mean(returns - MAR)/sqrt(sum(pmin(returns - MAR, 0)^2)/nrow(.))) Calculating Sortino Ratio in the Tidyquant world Now on to tidyquant, which allows us to apply the SortinoRatio function from PerformanceAnalytics to a tibble. sortino_tidy &lt;- portfolio_returns_tq_rebalanced_monthly %&gt;% tq_performance(Ra = returns, performance_fun = SortinoRatio, MAR = MAR, method = &quot;full&quot;) %&gt;% `colnames&lt;-`(&quot;ratio&quot;) Let’s compare our 3 Sortino objects. sortino_xts[1] ## [1] -0.03875197 sortino_byhand$ratio ## [1] -0.03875197 sortino_tidy$ratio ## [1] -0.03875197 We have consistent results from xts, tidyquant and our by-hand piped calculation. Again, the Sortino Ratio is most informative when compared to other Sortino Ratios. Is our portfolio’s Sortino good, great, awful? Let’s compare it to the Sortino Ratio of the S&amp;P500 in the same time period. market_returns_sortino &lt;- market_returns_tidy %&gt;% summarise(ratio = mean(returns - MAR)/sqrt(sum(pmin(returns - MAR, 0)^2)/nrow(.))) market_returns_sortino$ratio ## [1] 0.2203687 Ok, once again, the S&amp;P500 has beat our portfolio! That makes sense given that the S&amp;P500 also had a higher Sharpe Ratio. Visualizing the Sortino Ratio Let’s get a better grasp on what the Sortino Ratio is communicating by building some visualizations. First, we will get a sense for what proportion of our portfolio returns exceeded the MAR. Very similar to our work on the Shapre Ratio, we will add a column for returns that fall below MAR with mutate(returns_below_MAR = ifelse(returns &lt; MAR, returns, NA)) and add a column for returns above MAR with mutate(returns_above_MAR = ifelse(returns &gt; MAR, returns, NA)). We do this with an eye towards ggplot. sortino_byhand &lt;- portfolio_returns_tq_rebalanced_monthly %&gt;% mutate(ratio = mean(returns - MAR)/sqrt(sum(pmin(returns - MAR, 0)^2)/nrow(.))) %&gt;% mutate(returns_below_MAR = ifelse(returns &lt; MAR, returns, NA)) %&gt;% mutate(returns_above_MAR = ifelse(returns &gt; MAR, returns, NA)) Let’s use that new object and it’s new columns to create a scatterplot of returns using ggplot. to again grasp how many of our returns are above the MAR and how many are below the MAR. We will create green points for returns above MAR with geom_point(aes(y = returns_above_MAR), colour = &quot;green&quot;) and red points for returns below MAR with geom_point(aes(y = returns_below_MAR), colour = &quot;red&quot;). As we did with the Sharpe Ratio, let’s add a blue vertical line at November of 2016. We will also include a horizontal purple dotted line at the MAR. sortino_byhand %&gt;% ggplot(aes(x = date)) + geom_point(aes(y = returns_below_MAR), colour = &quot;red&quot;) + geom_point(aes(y = returns_above_MAR), colour = &quot;green&quot;) + geom_vline(xintercept = as.numeric(as.Date(&quot;2016-11-30&quot;)), color = &quot;blue&quot;) + geom_hline(yintercept = MAR, color = &quot;purple&quot;, linetype = &quot;dotted&quot;) + annotate(geom=&quot;text&quot;, x=as.Date(&quot;2016-11-30&quot;), y = -.05, label = &quot;Election&quot;, fontface = &quot;plain&quot;, angle = 90, alpha = .5, vjust = 1.5) + ylab(&quot;percent monthly returns&quot;) It appears that about half of our returns fall below the MAR. Do we consider that to be a successful portfolio? This is not a rigorous test - what strikes us from the number of red dots and where they fall? Do we notice a trend? A period with consistently below or above MAR returns? Since the election in 2016, there has been only two monthly returns below the MAR and that will lead to a large Sortino since November. Next we will build a histogram of the distribution of returns with geom_histogram(alpha = 0.25, binwidth = .01, fill = &quot;cornflowerblue&quot;). We will again add a line for the MAR. sortino_byhand %&gt;% ggplot(aes(x = returns)) + geom_histogram(alpha = 0.25, binwidth = .01, fill = &quot;cornflowerblue&quot;) + geom_vline(xintercept = MAR, color = &quot;green&quot;) + annotate(geom = &quot;text&quot;, x = MAR, y = 22, label = &quot;MAR&quot;, fontface = &quot;plain&quot;, angle = 90, alpha = .5, vjust = 1) The Sortino Ratio is often accompanied by a density plot and we’ll build one now. First, we will start simple with stat_density(geom = &quot;line&quot;, size = 1, color = &quot;cornflowerblue&quot;) to create a ggplot object called sortino_density_plot. sortino_density_plot &lt;- sortino_byhand %&gt;% ggplot(aes(x = returns)) + stat_density(geom = &quot;line&quot;, size = 1, color = &quot;cornflowerblue&quot;) sortino_density_plot A slight negative skew is a bit more evident here. It would be nice to shade the area that falls below the MAR. To do that, let’s create an object called shaded_area using ggplot_build(p)$data[[1]] %&gt;% filter(x &lt; MAR). That snippet will take our original ggplot object and create a new object filtered for x values less than MAR. Then we use geom_area to add the shaded area to sortino_density_plot. shaded_area_data &lt;- ggplot_build(sortino_density_plot)$data[[1]] %&gt;% filter(x &lt; MAR) sortino_density_plot_shaded &lt;- sortino_density_plot + geom_area(data = shaded_area_data, aes(x = x, y = y), fill=&quot;pink&quot;, alpha = 0.5) sortino_density_plot_shaded Let’s add a vertical line label at the exact MAR and an arrow to tell people where downside volatility resides. Note how we can keep adding layers to the sortino_density_plot_shaded object from above, which is one of great features of ggplot. It allows experimentation with aesthetics without changing the core plot with each iteration. sortino_density_plot_shaded + geom_segment(aes(x = 0, y = 1.5, xend = -.05, yend = 1.5), arrow = arrow(length = unit(0.4, &quot;cm&quot;)), size = .05) + geom_segment(data = shaded_area_data, aes(x = MAR, y = 0, xend = MAR, yend = y), color = &quot;red&quot;, linetype = &quot;dotted&quot;) + annotate(geom = &quot;text&quot;, x = MAR, y = 5, label = &quot;MAR = 0.8%&quot;, fontface = &quot;plain&quot;, angle = 90, alpha = .8, vjust = -1) + annotate(geom = &quot;text&quot;, x = -.02, y = .1, label = &quot;Downside&quot;, fontface = &quot;plain&quot;, alpha = .8, vjust = -1) As with our scatterplot, we have not been shy about aesthetic layering but one goal here is to explore ggplot tools, which gives us license to be overinclusive. We have done some good work for visualizing the portfolio’s returns and how they are distributed relative to the MAR, and how the MAR separates part of the the returns to downside risk. That gives us some intution about the Sortino Ratio. 3.0.1 Rolling Sortino Ratio with in the xts World As with Sharpe Ratio, let’s get to some rolling Sortinos. There is a slight wrinkle though - remember that we exclude above MAR returns from the denominator. If our rolling window is too small, we might end up with a denominator that includes 1 or 2 or 0 downside deviations. That would accurately reflect that the portfolio has done well in that small window but it might report a misleadingly huge number for the rolling window. The rolling 6 month demonstrates this. We calculate the rolling 6-month Sortino with rollapply(portfolio_returns_xts, window, function(x) SortinoRatio(x)). window &lt;- 6 rolling_sortino_xts &lt;- rollapply(portfolio_returns_xts_rebalanced_monthly, window, function(x) SortinoRatio(x, MAR = MAR)) %&gt;% na.omit() %&gt;% `colnames&lt;-`(&quot;sortino&quot;) 3.0.2 Rolling Sortino Ratio with in tidyverse + tibbletime Similar to what we did with the standard deviation and Sharpe Ratio, we can combine the tidyverse and tibbletime to run the rolling Sortino Ratio calculation on our data frame. Again we are going to write our own function to rollify(), but it’s the same function we used above to find the Sortino Ratio, ratio = mean(returns - MAR)/sqrt(sum(pmin(returns - MAR, 0)^2)/length(returns)). sortino_roll_6 &lt;- rollify(function(returns) { ratio = mean(returns - MAR)/sqrt(sum(pmin(returns - MAR, 0)^2)/length(returns)) }, window = 6) rolling_sortino_tidy_tibbletime &lt;- portfolio_returns_tq_rebalanced_monthly %&gt;% as_tbl_time(index = date) %&gt;% mutate(ratio = sortino_roll_6(returns)) %&gt;% na.omit() %&gt;% select(-returns) Let’s compare our objects. head(rolling_sortino_tidy_tibbletime) ## # A time tibble: 6 x 2 ## # Index: date ## date ratio ## &lt;date&gt; &lt;dbl&gt; ## 1 2013-07-31 0.0385 ## 2 2013-08-31 -0.183 ## 3 2013-09-30 0.124 ## 4 2013-10-31 0.249 ## 5 2013-11-30 0.453 ## 6 2013-12-31 1.06 head(rolling_sortino_xts) ## sortino ## 2013-07-31 0.03849593 ## 2013-08-30 -0.18317574 ## 2013-09-30 0.12423658 ## 2013-10-31 0.24937795 ## 2013-11-29 0.45311688 ## 2013-12-31 1.05547686 The results are consistent and we can start charting. Visualizing the Sortino Ratio Let’s start with highcharter and pass in our rolling_sortino_xts highchart(type = &quot;stock&quot;) %&gt;% hc_title(text = &quot;Rolling Sortino&quot;) %&gt;% hc_add_series(rolling_sortino_xts, name = &quot;Sortino&quot;, color = &quot;cornflowerblue&quot;) %&gt;% hc_navigator(enabled = FALSE) %&gt;% hc_scrollbar(enabled = FALSE) The rolling 6-month has so many bizarre spikes. It nicely emphasizes how we need to be careful with the Sortino Ratio, short time periods and rolling applications. Let’s see how the rolling 24-month compares. portfolio_sortino_roll_24_xts &lt;- rollapply(portfolio_returns_xts_rebalanced_monthly, 24, function(x) SortinoRatio(x, MAR = MAR)) highchart(type = &quot;stock&quot;) %&gt;% hc_title(text = &quot;Rolling Sortino&quot;) %&gt;% hc_add_series(portfolio_sortino_roll_24_xts, name = &quot;Sortino 24&quot;, color = &quot;lightgreen&quot;) %&gt;% hc_navigator(enabled = FALSE) %&gt;% hc_scrollbar(enabled = FALSE) Ah, much better. We can see the movements and how the Sortino has changed through the life of this portfolio, but within a reasonable range of .6 to -0.4. Let’s compare to the rolling S&amp;P500 Sortino. market_sortino_roll_24_xts &lt;- rollapply(market_returns_xts, 24, function(x) SortinoRatio(x, MAR = MAR)) highchart(type = &quot;stock&quot;) %&gt;% hc_title(text = &quot;Rolling sharpe&quot;) %&gt;% hc_add_series(portfolio_sortino_roll_24_xts, name = &quot;Portfolio&quot;, color = &quot;cornflowerblue&quot;) %&gt;% hc_add_series(market_sortino_roll_24_xts, name = &quot;SP500&quot;, color = &quot;green&quot;) %&gt;% hc_navigator(enabled = FALSE) %&gt;% hc_scrollbar(enabled = FALSE) I am not going to port these rolling Sortinos to ggplot and the tidyverse, but it would follow the exact same code flow as we use for the Sharpe Ratio. Give it a shot! Rolling Sortinos need to be handled with care but there are a few nice payoffs. First, these charts force us and our end users to reflect on how time periods can affect Sortino to extremes. Be skeptical if someone reports a fantastic 6-month Sortino. Second, as an exploratory device, the rolling ratios highligh time periods deserving of more investigation. Third, with Sortino (and Sharpe) Ratios, there’s a temptation to look at the final number for a portfolio’s life and judge it ‘good’ or ‘bad’. These rolling visualizations can help reframe the analysis and look at how the portfolio behaved in different economic and market regimes. Shiny Sortino Ratio Let’s wrap this up into a Shiny app and notice how similar it is to the Sharpe Ratio app in structure. Here is the link and snapshot: www.reproduciblefinance.com/shiny/sortino-ratio/ FIGURE 3.1: Sortino Ratio Shiny App We just saw how the calculations are different from Sharpe to Shiny, but from a Shiny input perspective, the only difference is that the end user chooses a MAR instead of a risk-free rate. fluidRow( column(5, numericInput(&quot;mar&quot;, &quot;MAR%&quot;, .8, min = 0, max = 3, step = .01)), column(5, numericInput(&quot;window&quot;, &quot;Window&quot;, 6, min = 2, max = 24, step = 2)) ) Note that we ask for a MAR percent. Thus, when calculating the reactive, we divide by 100. mar &lt;- eventReactive(input$go, {input$mar/100}) Why do that? No substantive reason - perhaps it’s more intuitive to the user and it keeps the input box from getting too wide. On that same theme, I removed the value boxes so the user doesn’t get to see the overall Sortino Ratio for the portfolio and the market. Why? Going back to the idea of experimentation, I would be curious to see if users preferred the value boxes in the Sharpe Ratio app or the cleaner Sortino Ratio. Beyond preference, would they get a different signal? Perhaps end users would be drawn to those value boxes, for better or worse, and ignore the rolling visualizations. From there, the app is virtually identical to the Sharpe Ratio app except that I included a density chart, which I think suits a Sortino Ratio. The code for that is similar to how we have created other density charts with the addition of a line at the MAR. renderPlot({ validate(need(input$go != 0, &quot;Please choose your portfolio assets, weights, MAR, rolling window and start date and click submit.&quot;)) MAR &lt;- mar() portfolio_returns_tq_rebalanced_monthly &lt;- portfolio_returns_tq_rebalanced_monthly() sortino_density_plot &lt;- portfolio_returns_tq_rebalanced_monthly %&gt;% ggplot(aes(x = returns)) + stat_density(geom = &quot;line&quot;, size = 1, color = &quot;cornflowerblue&quot;) shaded_area_data &lt;- ggplot_build(sortino_density_plot)$data[[1]] %&gt;% filter(x &lt; MAR) sortino_density_plot + geom_area(data = shaded_area_data, aes(x = x, y = y), fill=&quot;pink&quot;, alpha = 0.5) + geom_segment(data = shaded_area_data, aes(x = MAR, y = 0, xend = MAR, yend = y), color = &quot;red&quot;, linetype = &quot;dotted&quot;) + annotate(geom = &quot;text&quot;, x = MAR, y = 5, label = paste(&quot;MAR =&quot;, MAR, sep = &quot;&quot;), fontface = &quot;plain&quot;, angle = 90, alpha = .8, vjust = -1) + annotate(geom = &quot;text&quot;, x = (MAR - .02), y = .1, label = &quot;Downside&quot;, fontface = &quot;plain&quot;, alpha = .8, vjust = -1) }) That’s all for our Sortino app. The building of this app was greatly aided by our previous work on visualizing returns and building a Sharpe Ratio app. We can move faster as we build on the past. Next we will change gears a bit and look at CAPM and beta. Markowitz, Harry. Portfolio Selection: Efficient Diversification of Investments, John Wiley &amp; Sons, 1959↩ "]
]
